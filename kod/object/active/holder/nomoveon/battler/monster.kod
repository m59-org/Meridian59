% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Monster is Battler

constants:

   include blakston.khd
   include protocol.khd

   % 9 minutes
   TURN_TIME = 9*60*1000   

   % How many percents between each message for how much a player needs to
   %  learn to qualify for a new spell.
   MONSTER_LEARN_GRADIENT = 15

   % Values returned by UserGet
   AUTOLOOT_GOT_ITEM = 1
   AUTOLOOT_OUT_OF_RANGE = 2
   AUTOLOOT_GOT_PARTIAL_STACK = 3
   AUTOLOOT_CANNOT_GET = 4

   % Number of ms to lose one boosted health or mana point.
   BOOST_DECAY_TIME = 30000 
   
   TIER_ONE_CHAMPION_REWARD_MULTIPLIER = 3
   TIER_TWO_CHAMPION_REWARD_MULTIPLIER = 10
   TIER_THREE_CHAMPION_REWARD_MULTIPLIER = 100
   
   % Champion abilities 
   % Stored in the form [type, value] in plChampionAbilities
   %CHAMPION_ABIL_MAGIC_RESISTANCE = 1
   %CHAMPION_ABIL_WEAPON_RESISTANCE = 2
   %CHAMPION_ABIL_EAGLE_EYES = 3
   %CHAMPION_ABIL_FREE_ACTION = 4
   %CHAMPION_ABIL_ELEMENTAL_DAMAGE_TYPE = 5
   %CHAMPION_ABIL_PURGE = 6
   %CHAMPION_ABIL_DISARM = 7
   
   % Every 20 loyalty is 1 minute on an average monster
   % So 200 loyalty is 10 minutes per binding level
   % Binding level 9 is roughly 90 minutes
   % LOYALTY_PER_BINDING_LEVEL = 200

resources:

   include monster.lkod

   monster_percent_q = "%q"
   monster_color_blue_rsc = "~b"

   monster_plural = "s"
   monster_little = "a little "             % for under 15pts to gain
   monster_nothing = ""                     % for 15-30 pts to gain
   monster_some = "some "                   % for 30-45 pts to gain
   monster_much = "much "                   % for 45-60 pts to gain
   monster_significantly = "significantly " % for 60-75 pts to gain
   monster_drastically = "drastically "     % for 75+ pts to gain

   monster_teach_karma = \
      "Your karma is not far enough along the true path for you to learn %s." 
   monster_teach_quest_needed = \
      "I can teach you %s, but first you must prove your worth as a pupil."
   monster_teach_base = \
      "Your mind is focused properly, and with %sfurther progress in the "
      "previous %s levels you can learn %s." 
   monster_teach_success = \
      "You are currently qualified to learn %s.  Congratulations."  
   monster_teach_already = "You have already been taught %s."
   monster_teach_nobase = \
      "You first need to have some knowledge of the previous level before you "
      "can learn %s."
   monster_teach_impossible = \
      "Indeed, you have learned so much already! A fine accomplishment.  You "
      "have no... need... to learn further in this school."

   monster_level = "level"
   monster_one = "one"
   monster_num_one = "1"
   monster_two = "two"
   monster_num_two = "2"
   monster_three = "three"
   monster_num_three = "3"
   monster_four = "four"
   monster_num_four = "4"
   monster_five = "five"
   monster_num_five = "5"
   monster_six = "six"
   monster_num_six = "6"
   monster_said_resource_str = "%s%s says, \"%s~n\""

   monster_teach_comma = ", "
   monster_teach_and = "and "
   monster_teach_blank = ""

   monster_sch_weaponcraft = "Weaponcraft"
   monster_sch_kraanan = "Kraanan magic"
   monster_sch_shalille = "Shal'ille magic"
   monster_sch_qor = "Qor magic"
   monster_sch_faren = "Faren magic"
   monster_schools_faren_shalille = "Shal'ille and Faren magic"
   monster_schools_qor_shalille = "Shal'ille and Qor magic"
   monster_school_qor_faren = "Qor and Faren magic"
   monster_division_combat = "Weaponcraft and Kraanan magic"
   monster_division_magic = "Shal'ille, Faren, and Qor magic"

   monster_anonymous_response = \
      "%s looks at you with a peculiar expression and does not respond." 

   player_has_ventdal = \
      "I do not teach pathetic Ventdal traditionalists."
   player_has_xaerdun = \
      "A greedy follower of Xaerdun will learn nothing from me."
   player_has_iwodach = \
      "Collection protocols deny cross-contamination of data."
   player_has_nequzon = \
      "A wild-witch of Nequzon has no use for scholarly knowledge. Begone."

   LS_Cant_part = \
      "I cannot see how you could bear to part with %s%s!  I certainly "
      "couldn't be the one to take it off your hands."
   LS_Signet_returned = \
      "Oh! I was sure this was lost forever.  Thank you very, very much for "
      "bringing it back to me.  Here, let me give you a small reward."
   LS_Signet_wrong = \
      "An heirloom for sure.  You should take it to %s%s yourself.  There's "
      "likely to be a reward for its return."
   LS_already_done_permquest = \
      "You have already earned my favor; you need not keep trying."
   LS_unwanted_oldquest = \
      "Sorry you went to such trouble, but someone else already gave me that."
   LS_wanted_keep = "Thank you.  I will someday return the favor."
   LS_unwanted_keep = \
      "~k%s%s tells you, \"Thank you.  It is very nice of you to just give "
      "this to me.~n~k\""
   LS_unwanted_pay = \
      "~k%s%s tells you, \"Here.  I'll give you a few shillings for "
      "this.~n~k\""
   LS_unwanted_give = \
      "~k%s%s tells you, \"I simply have no need for that.~n~k\""
   LS_unwanted_token = \
      "~k%s%s tells you, \"I am honored to hold it briefly, but this token "
      "must be returned to the member of the Meridian Council who studies "
      "it.  I'm afraid I must give it back to you.~n~k\""
   LS_nofight_attacked = \
      "You have a funny feeling that attacking is pointless."

   Lm_nothing_for_sale = "I'm afraid I have nothing to sell right now."

   Lm_first_damage_level = "~B~r%s%s is slightly wounded."
   Lm_second_damage_level = "~B~r%s%s is clearly injured."
   Lm_third_damage_level = "~B~r%s%s is seriously wounded."
   Lm_fourth_damage_level = "~B~r%s%s is weak, and near death."
   Lm_party_killed_monster = "~B%s%s has valiantly slain %s%s!"

   Lm_monster_healing = \
      "%s%s falls back to recover for a moment, then returns to the fight."
   
   champion_tough_desc = \
      "\n\nThis %s looks rather tough."
   champion_swift_desc = \
      "\n\nThis %s seems to move rather swiftly."
   champion_deadly_desc = \
      "\n\nThis %s appears exceptionally deadly."
   champion_indomitable_desc = \
      "\n\nThis %s clearly possesses an indomitable strength."
   champion_legendary_desc = \
      "\n\nThis is a legendary %s, a renowned terror upon the land!"
   champion_nothing = \
      ""
   
   monster_blank_level = ""
   monster_desc_level = "This monster is level %i."
   Lm_condition_healthy = "%r%s\n\n%r%r"
   Lm_condition_good = \
      "%r%s\n\n%r\n\n%s%s is injured, but is still relatively strong.%r"
   Lm_condition_fair = \
      "%r%s\n\n%r\n\n%s%s is wounded, but is still relatively strong.%r"
   Lm_condition_poor = "%r%s\n\n%r\n\n%s%s is suffering from deep wounds.%r"
   Lm_condition_bad = \
      "%r%s\n\n%r\n\n%s%s is weak and seems unlikely to survive much longer.%r"

   Lm_cant_remove_item = "You can't give %s%s away right now."
   Lm_mrcnt_not_selling = "You tried to buy something that is not being sold."
   Lm_mrcnt_too_costly = "Come back when you have enough money for %s%s."
   Lm_mrcnt_cant_give = \
      "I'm unable to give you %s%s.  Perhaps you carry too much?"
   Lm_mrcnt_can_give_some = \
      "It looks like you can only hold some of %s%s. I'll reduce your tally."

   Lm_only_receiver = "%s%s says, \"I don't buy things, but I do take gifts.\""
   Lm_buyer_offer_busy = "%s is busy right now with another customer." 
   Lm_buyer_no_value = "I can't even give you a shilling for that."
   Lm_buyer_timeout = \
      "Can't make up your mind?  Think on it and come back when you are ready."
   Lm_buyer_unwanted = "I'm not interested."
   Lm_bnkr_balance = "You have %i shillings in your account."
   Lm_bnkr_did_deposit = \
      "Thank you for your deposit.  You now have %i shillings in your account."
   Lm_bnkr_no_account = "You have no money to withdraw!"
   Lm_bnkr_acct_full = \
      "You have so many shillings stored here, that I'm afraid I have no "
      "space to store any more!"
   Lm_bnkr_acct_almost_full = \
      "You have so many shillings stored here, that I'm afraid I can only "
      "store %i more."
   Lm_bnkr_not_enough_withdraw = \
      "But you only have %i shillings in your account!"
   Lm_bnkr_not_enough_deposit = \
      "But you only have %i shillings in your possession!"
   Lm_bnkr_did_withdraw = \
      "Here are your %i shillings. Thank you for your business."
   Lm_bnkr_player_full = \
      "I swear, if I gave you a shilling more than %i you'd topple right over!"
   Lm_bnkr_player_all_full = "You can't hold even a single shilling more!"

   vaultman_nogold = "You may not use my services to store %s%s."
   vaultman_nocursed = "I cannot take %s%s from you."
   vaultman_fullvault = \
      "Your vault cannot hold that much stuff!  Perhaps you should try "
      "offering items in smaller quantities."
   vaultman_thanks_amount = \
      "That will cost %i shillings.  Thank you for trusting me to "
      "quartermaster your gear."
   vaultman_dont_have = "Hmmm, I can't seem to find %s%s in your vault."
   vaultman_no_room = \
      "You can't carry all of that!  Perhaps you should try withdrawing the "
      "items one at a time."
   vaultman_deposit_thanks = \
      "Thank you for trusting me to quartermaster your gear."
   vaultman_thanks = "Here is your gear.  Thank you for your patronage."
   vaultman_withdraw_failed = \
      "I was unable to complete our transaction.  Please sort your inventory "
      "and try again."
   vaultman_nowithdraw_cash = \
      "You currently cannot pay the exit fee to get your stuff out."
   vaultman_nodeposit_cash = \
      "Storing these items would cost %i shillings - which I see you do not "
      "have."
   vaultman_cant_part = \
      "Wow... I couldn't feel responsible if your %s were to disappear - I "
      "cannot store it."
   vaultman_noaccount = "I do not seem to be storing any of your gear."
   vaultman_not_enough = "You don't have that many %s stored in your name!"

   monster_say_to_one = "~k%s%s tells you, \"%s~n~k\""

   monster_iteach = "I teach %s%s%s%s%s%s%s%s%s%s%s%s at that level."
   monster_teachnothing = "I teach no abilities at that level."

   monster_koc_name = "moch"

   monster_report_balance = \
      "~B~g[~n~k%s%s tells you, \"%q has %i shillings in this bank.\"~B~g]"
   Monster_Sweep_Reward = \
      "Hmm... that looks a bit cleaner.  Here, take this as payment, %s%s."

   monster_default_attack = "attack"
   minion_trouble = \
      "You sense your minion has gotten you into some trouble..."

   autolooted_all = "You loot the corpse clean, and find %d shillings."
   autolooted_all_no_money = "You loot the corpse clean."
   autolooted_some = "You loot some of the items from your fallen kill, and "
      "find %d shillings."
   autolooted_some_no_money = "You loot some of the items from your fallen enemy."
   autolooted_only_money = "You find nothing easily lootable on your slain "
      "enemy other than %d shillings."
   autolooted_none = "You find nothing easily lootable on your slain enemy."
     
   autoloot_too_far_away = "You're too far away to loot your fallen enemy!"
   autoloot_got_some_but_full_now = "You pick up some of your slain enemy's "
      "loot, but find yourself too encumbered to get it all."
   autoloot_got_nothing_because_full= "You can't carry any more, so you loot "
      "nothing from your fallen enemy."
   autoloot_got_only_shillings_because_full = "You can't carry any more, so you "
      "loot nothing from your fallen enemy, but you do find %d shillings."

   monster_faction_negative_msg = \
      "Your standing with The %s has decreased"

   monster_faction_positive_msg = \
      "Your standing with The %s has increased"

   monster_faction_unspecified = "UNSPECIFIED MONSTER FACTION!"
   monster_faction_farol = "Minions of Life"
   monster_faction_orc = "Orcs"
   monster_faction_troll = "Trolls"
   monster_faction_farnohl = "House of Lord Far'Nohl"
   monster_faction_lich = "Subjects of Queen Venya'cyr"
   monster_faction_psavar = "Peet-Seeeep Avar Clan"
   monster_faction_kkavar = "Kyip-Kyip-Kreeet Avar Clan"
   monster_faction_ctavar = "Chyup-Tewee Avar Clan"
   monster_faction_fey_good = "Fey Elhai"
   monster_faction_fey_evil = "Fey Dirhai"
   monster_faction_frogmen = "Frogmen"
   monster_faction_heretic = "Cult of the Three"
   monster_faction_undead = "Minions of Death"

   champion_none = ""
   champion_tough_prefix = "tough "
   champion_speed_prefix = "swift "
   champion_damage_prefix = "deadly "
   champion_all_prefix = "indomitable "
   champion_super_prefix = "legendary "
   
   legendary_name_none = "Allan please add legendary name"
   legendary_name_default = "Ror'thark the Merciless"
   
   champion_purge_msg = "The attack tears at the magics surrounding you!"
   champion_disarm_msg = "The skilled strike knocks you off balance!"
   
   indomitable_arrived = "An indomitable %s steps forward, ready for combat!"
   legendary_arrived = "~BA legendary %s appears, intent on destroying you!"

   minion_breaks_free = \
      "~B%s%s is no longer under your control!"
      
   minion_breaks_bind_level_high = \
      "~B%s%s seems a little restless."
   minion_breaks_bind_level_low = \
      "~B%s%s seems to be breaking free of your control!"

   minion_bind_level_blank = \
      ""
   minion_bind_level_10 = \
      "%s%s is permanently bound as a minion of %s%s.\n\n"
   minion_bind_level_9 = \
      "%s%s is a fanatical minion of %s%s.\n\n"
   minion_bind_level_8 = \
      "%s%s is a minion of %s%s.\n\n"
   minion_bind_level_7 = \
      "%s%s is an eager servant of %s%s.\n\n"
   minion_bind_level_6 = \
      "%s%s is a servant of %s%s.\n\n"
   minion_bind_level_5 = \
      "%s%s is strongly bound to fight for %s%s.\n\n"
   minion_bind_level_4 = \
      "%s%s is bound to fight for %s%s.\n\n"
   minion_bind_level_3 = \
      "%s%s is bound to fight alongside %s%s.\n\n"
   minion_bind_level_2 = \
      "%s%s is compelled to aid %s%s.\n\n"
   minion_bind_level_1 = \
      "%s%s is lightly compelled to aid %s%s.\n\n"
   minion_bind_level_0 = \
      "%s%s is barely compelled to aid %s%s.\n\n"
   minion_bind_level_nothing = \
      "%s%s%s%s"

   monster_spell_build_1_sound = monsterspellbuild1.wav
   monster_spell_build_2_sound = monsterspellbuild2.wav
   monster_spell_build_3_sound = monsterspellbuild3.wav
   monster_spell_build_4_sound = monsterspellbuild4.wav
   
   monster_jailer_you_cannot_control_it = \
      "Can't sell you that one. It'd turn on you in a second. Try a weaker one maybe, or getting rid of some existing minions..."
   monster_jailer_sold_to_you = \
      "Good luck with that one... we gave it a complementary creature binding for you, but you never know..."
   
classvars:

   vrKocName = monster_koc_name
   viGender = GENDER_NEUTER
   
   viLanguage = LANGUAGE_NONE
   
   vbNamedMob = FALSE
   
   vrDead_icon = $
   vrDead_name = $

   viAttack_type = ATCK_WEAP_HIT
   viAttack_spell = 0
   viMerchant_markup = MERCHANT_NORMAL
   viCancel_offer_time = 30000
   % Default to teleport if there's no move anim, also used for movement timer
   %  (range is 1 to 20)
   viSpeed = 0

   viTreasure_type = TID_NONE

   % Random delay from delay to 1.50*delay
   viRandom_delay = 40000
   % from delay to 1.33*delay
   viSpasm_delay  = 15000

   viQuestID      = 0
   % viAttributes is a bitvector of behavior and services
   viAttributes   = 0
   % viOccupation is what this mob does for a living, used for NPCs.
   viOccupation   = 0
   viKarma        = 0

   % If the monster is undead, set this to TRUE.
   vbIsUndead = FALSE
   
   % If the monster is shadow or darkness, set this to TRUE.
   vbIsShadow = FALSE

   % viLevel ranges from 25 to 200 (150 and above is for "boss" mobs)
   %  determines hit points.
   viLevel        = 25

   % viDifficulty ranges from 1 to 9, increases combat prowess. 10 can
   % be used but is far too difficult for general use.
   viDifficulty = 0

   % viVisionDistance is the radius (in row/col units) that the monster
   % can see within. Default 10.
   viVisionDistance = 10

   % viAttackRange is the radius (in FINENESS units) that the monster
   % can attack within. Default 128, or 2 row/cols.
   viAttackRange = 128

   % All monsters use BRAIN_ORIGINAL for now.
   viBrain_type = BRAIN_ORIGINAL

   % Bitvector for monster/NPC behaviors. This variable contains the flags
   % monsters use for determining combat/aggro behavior.
   viDefault_behavior = 0

   viCashmin = 1
   viCashmax = 10

   % 1 in x chance to cast a spell. Default 10% chance.
   viSpellChance = 10

   viWimpy = 0

   % If true, items that are sold actually come out of the monster's
   %inventory. If false, the items in the inventory are inexhaustible
   % templates, and copies are sold.
   vbSellFromInventory = FALSE

   vrCondition_healthy = Lm_condition_healthy
   vrCondition_good = Lm_condition_good
   vrCondition_fair = Lm_condition_fair
   vrCondition_poor = Lm_condition_poor
   vrCondition_bad = Lm_condition_bad
   vrFirst_damage_level = Lm_first_damage_level
   vrSecond_damage_level = Lm_second_damage_level
   vrThird_damage_level = Lm_third_damage_level
   vrFourth_damage_level = Lm_fourth_damage_level
   vrParty_killed_monster = Lm_party_killed_monster

   vrTeach_message = monster_iteach
   vrTeach_nothing = monster_teachnothing
   vrUnwanted_keep = LS_unwanted_keep
   vrUnwanted_pay = LS_unwanted_pay
   vrUnwanted_give = LS_unwanted_give
   vrUnwanted_token = LS_unwanted_token
   vrTeach_quest_needed = monster_teach_quest_needed
   vrNothing_for_sale = Lm_nothing_for_sale
   vrMrcnt_too_costly = Lm_mrcnt_too_costly
   vrMonster_healing = Lm_monster_healing
   vrMinion_trouble = minion_trouble

   % Obsolete, but still included here for safety's sake.
   vrSound_hit = $
   vrSound_miss = $
   vrSound_aware = $
   vrSound_death = $

   viDead_drawfx = 0

   viFaction = FACTION_NEUTRAL

   viCanSpawnAsChampion = TRUE
   viHasLegendaryNames = FALSE
   
   vbIgnoresAnonAndMorph = TRUE
   
   viBonusBaseTP = 0

   % between 1 and 10000
   viCriticalHitRate = 0
   vbCanCauseStun = FALSE
   vbCanCauseKnockback = FALSE
   vbCanCauseBleed = FALSE
   
   % Squared fine range limit on reacting to heals?
   viReactToHealFineDist = 6 * 64
   
   % Typically used for bosses, but also any hard monster is fine.
   % Does not change gain divisors for player hp vs monster hp.
   % For example, can't keep leveling up off an orc pit boss at 100+ hp.
   vbBonusXPGain = 0
   
   % If 0, monster leadership cost is equal to piLevel
   viLeadershipCost = 0
   
   % How much leadership does this monster have?
   viLeadershipMax = 400
   
   % Does this monster have a ranged attack?
   vbHasRangedAttack = FALSE
   viRangedAttackChance = 10
   viRangedAttackRange = 1600
   
   vbBreathesWater = FALSE
   vbBreathesAir = TRUE

properties:

   piVisionDistance
   piAttackRange
   piAnimation = ANIM_NONE

   % List of the mobs wanted items.
   plWantedItems = $
   % List of items offered to the player by buyer.
   plOffer_items = $
   % List of items offered to the player by seller.
   % [item list, skill list, spell list, conditional items (?)]
   plFor_sale = $

   ptCancelOffer = $
   ptRandom = $
   ptSpasm = $

   % IMPORTANT NOTE: For higher accuracy, a battler's current health 
   %(and only current health) is inflated by a factor of 100. Doing so 
   % avoids truncation errors but is not revealed to users in any way.
   piHit_points = 1
   piMax_hit_points = 1

   % Who we are dealing with.
   poCustomer = $

   poBrain = $

   piTargetLocationRow
   piTargetLocationCol
   piTargetLocationFineRow = 0
   piTargetLocationFineCol = 0
   piPatrolAttempts = 0
   plPatrolPath = $
   piPatrolNode = 0
   % chance to move to next patrol node (1 to 10000)
   piChanceToPatrol = 125

   %%% The Monster State Meta-Object

   % These should be modified only by the EnterStateX routines
   % Who to chase or attack
   poTarget = $
   % Bitvector of personality and mutable behavior
   piState = 0
   % Either chasing, moving, or attacking
   ptBehavior = $
   % Behavior flags = have prefix of AI_
   % All mobs will loop through a patrol path, if one is available.
   piBehavior = AI_LOOPING_PATROL
   % Who is our master, if we have one.
   poMaster = $
   % Flag used for minion moves around master
   piKeepWalkingSteps = 0
   % Player who has turned us.
   poHolySymbolCaster = $
   % Timer to expire turning.
   ptUnturn = $
   piHatred = 0
   % Emulates agility and aim for monsters based on difficulty.
   piAgility = 25
   piAim = 25

   % Emulates tumbling skill, 0 is no evasion, 100 is total evasion
   piTumbling = 0

   % Supports enchantments with monsters as targets
   plEnchantments = $

   piEnch_flags = 0

   piDrawfx = 0

   % A list of quest nodes for which this monster is the destination NPC
   plActiveQuestNodes = $
   pbIllusion = FALSE
   vbSummoned = FALSE

   % Apparition object (caster)
   poApparitionCaster = $

   % Should this monster stick around through a call to DestroyDisposable()?
   pbDontDispose = FALSE

   piMood = 0

   % list of keyed speechlib items [class, key] triggered since last
   %  RandomTimer firing
   plSpamList = $

   piColor_Translation = 0

   piSweepCounter = 0

   % List of spells this monster can cast. Has the format:
   % [ Spell num, mana cost, number req. from Random(1,100) to cast, base spellpower for this spell ]
   % Melee spell book occurs instead of close range attacks
   % Ranged spell book occurs instead of chase movement
   % Ally spell book includes spells to cast on allies
   % Other spell book includes custom spells for custom AI
   plMeleeSpellBook = $
   plRangedSpellBook = $
   plSelfSpellBook = $
   plAllySpellBook = $
   plOtherSpellBook = $
   
   % Use to trigger actions that aren't instant
   piQueuedSpellType = 0
   
   % What are the monster's chances to cast spells each check?
   % Number is out of one hundred
   piMeleeSpellChance = 10
   piRangedSpellChance = 10
   piAllySpellChance = 10
   piSelfSpellChance = 10
   piOtherSpellChance = 10
   
   % Let's limit monster casting to prevent classic Meridian spell spam.
   ptSpellCastTimer = $
   % Minimum time in MS between monster casts.
   piMonsterCastDelayMinimum = 2000

   % 1 in x chance to cast a spell. Default 10% chance. Set
   % from classvar in Constructor.
   piSpellChance = 10

   % Monster's spellpower. Default 50 sp.
   piSpellPower = 50

   % Monster's spell range, in FINENESS units. Default is 25 row/cols.
   piSpellRange = 1600

   piOffense = $
   piDefense = $
   piMinDamage = $
   piMaxDamage = $

   piArmor = 0
   
   % Was this monster boosted by a Survival Room?
   piBoostedLevel = 0

   % Was this monster boosted by a Chaos Stratum?
   piChaosLevel = 0
   
   piLastTimeAttacked = 0
   poLastAttacker = $

   % Keeps track of a mob's randomly generated extra strengths
   piChampionStatus = 0
   plChampionAbilities = $
   
   % Usually taken from monster's viSpeed
   piAttackSpeed = $
   piMoveSpeed = $
   
   % Save monster's move speed in the case of being a minion
   piSavedMovedSpeed = 0

   % 6 = 4000 ms, 8 = 3000 ms, 12 = 2000 ms, 24 = 1000 ms
   piCastSpeed = 6
   ptCastingAnimationTimer = $
   piCastPower = 0
   piCastingSID = 0
   piCastingRequiredPower = 240
   piCastingColor = 0

   % some monsters are created on the fly (ex: avar) we may need to set this at
   % runtime
   piReputationGroup = REP_NEUTRAL
   plReputationEnemies = $

   % 20 seconds default for players, 60 for monsters
   piHurtMeTime = 60000

   piLevel = 20
   
   piApplyElementalImbalancePower = 0
   
   % Level of binding as a charmed monster
   piLoyalty = 0
   ptLoyaltyTimer = $
   
   piAmountAddedToMonsterChasers = 0
   
   ptDrowningTimer = $
   piDrowningDelay = 3000
   piDrowningDamage = 1000

   poEventSpawner = $

messages:

   Constructor(template=FALSE, color=0, piSurvivalLevel=0, iBrain = 0, iChaosLevel = 0, oEventSpawner = $)
   "Simple enough, we create a monster. If they are questworthy, we note it."
   {
      local iStatPoints, iMin, iMax, oChaosMaint, iChaosDiff;

      poEventSpawner = oEventSpawner;

      iChaosDiff = 0;
      if iChaosLevel > 0
      {
         oChaosMaint = Send(SYS,@GetChaosStrataMaintenance);
      
         if oChaosMaint <> $
         {
            iChaosDiff = Send(oChaosMaint,@GetChaosDifficulty);
         }
         piLevel = Bound(180 + iChaosLevel/2,20,250);
      }
      else
      {
         piLevel = viLevel;
      }
      piMax_Hit_points = Send(Self,@Fuzzy,#num=Send(self,@GetMaxHitPoints))
                         + piSurvivalLevel*viDifficulty
                         + (iChaosLevel * iChaosDiff);
      
      piHit_points = piMax_hit_points*100;
      
      if iChaosLevel > 0
      {
         piMana = Bound(piMax_mana,20,$) + iChaosLevel;
      }
      else
      {
         piMana = piMax_mana;
      }
      piAttackRange = viAttackRange;
      piSpellChance = viSpellChance;
      piVisionDistance = viVisionDistance + piSurvivalLevel + iChaosLevel;
      piBoostedLevel = piSurvivalLevel;
      piChaosLevel = iChaosLevel;
      
      if piAttackSpeed = $
      {
         piAttackSpeed = viSpeed;
      }
      
      if piMoveSpeed = $
      {
         piMoveSpeed = viSpeed;
      }

      if Send(self,@MobIsSeller)
      {
         Send(Self,@SetForSale);
      }

      if Send(self,@MobIsCondSeller)
      {
         Send(Self,@InitCondSale);
      }

      if (viDefault_behavior & AI_NPC) = AI_NPC
      {
         Send(Send(SYS,@GetLibrary),@AddNPC,#who=self);
      }

      if viOccupation <> 0
         AND NOT template
      {
         % template set to TRUE means this monster is in the System
         % monster template list, so we shouldn't add it.
         Send(Send(SYS,@GetLibrary),@AddToOccupationList,#who=self);
      }

      Send(self,@TryAddToQuestEngine);

      if (iBrain > 0 AND iBrain <= BRAIN_MAX_NUM)
      {
         poBrain = Send(SYS,@FindBrainByNum,#num=iBrain);
      }
      else
      {
         poBrain = Send(SYS,@FindBrainByNum,#num=viBrain_type);
      }
      
      piState = piState & ESTATE_ZERO_MASK;
      Send(poBrain,@MobConstructor,#mob=self);

      piEnch_flags = 0;

      Send(self,@ClearActiveQuests);
      Send(self,@ResetBehaviorFlags);

      piMood = 0;

      iStatPoints = (viDifficulty + 1) * 10;

      if iStatPoints - 1 > 50
      {
         iMax = 50;
      }
      else
      {
         iMax = iStatpoints - 1;
      }

      if iStatPoints - 50 < 1
      {
         iMin = 1;
      }
      else
      {
         iMin = iStatpoints - 50;
      }

      if iMin > iMax
      {
         piAgility = iMax;
      }
      else
      {
         piAgility = Random(iMin,iMax);
      }
      piAim = iStatPoints - piAgility;

      if piSurvivalLevel > 0
      {
         piOffense = Send(self,@GetOffense) + piSurvivalLevel*viDifficulty + piChaosLevel*iChaosDiff;
         piDefense = Send(self,@GetDefense) + piSurvivalLevel*viDifficulty + piChaosLevel*iChaosDiff;
         piMinDamage = piLevel/15 + piSurvivalLevel/2 + piChaosLevel/2;
         piMaxDamage = piLevel/10 + piSurvivalLevel/2 + piChaosLevel/2;
         piArmor = piSurvivalLevel/5 + piChaosLevel/5;
      }

      if piChaosLevel > 0
      {
         piOffense = Send(self,@GetOffense) + piChaosLevel*iChaosDiff;
         piDefense = Send(self,@GetDefense) + piChaosLevel*iChaosDiff;
         piMinDamage = piLevel/15 + piChaosLevel/2;
         piMaxDamage = piLevel/10 + piChaosLevel/2;
         piArmor = piChaosLevel/5;
      }

      if viBonusBaseTP <> 0
      {
         % for special bonuses, keep track up to five minutes.
         piHurtMeTime = 60000 * 5;
      }

      if color <> 0
      {
         piColor_translation = color;
      }
      
      plCreatureTypes = Cons(CREATURE_TYPE_MONSTER,plCreatureTypes);

      propagate;
   }
   
   Constructed()
   {
      local lSpells;
      Post(self,@AddChampionAbility,#ability=CHAMPION_ABIL_EAGLE_EYES,#value=Bound(piLevel/4,0,50));
      
      if piChaosLevel > 0
      {
         lSpells = [SID_BLAST_OF_FIRE,
                    SID_EXPLOSIVE_FROST,
                    SID_SPLASH_OF_ACID,
                    SID_ILLUSIONARY_WOUNDS,
                    SID_PURGE,
                    SID_HOLD,
                    SID_HEX_FRAILTY,
                    SID_HEX_VULNERABILITY];
         Send(self,@CreateMeleeSpellBookIfNew,#iSID=Nth(lSpells,Random(1,Length(lSpells))),#iManaCost=Random(2,5),#iChance=100,#iSpellpower=piChaosLevel);
      }

      piSavedMovedSpeed = piMoveSpeed;

      propagate;
   }

   SetPatrolPath(lPath = $)
   {
      if (lPath <> $)
      {
         plPatrolPath = lPath;
         Send(self,@SetBehaviorFlag,#flag=AI_CAN_PATROL,#value=TRUE);
      }

      return;
   }

   GetKocName()
   {
      return vrKocName;
   }

   IsNamedMob()
   {
      return vbNamedMob;
   }

   % Overridden for specific NPCs,
   % common point for mood changes, except word triggers
   AffectMood( why = $, what = $ )
   {
      return;
   }

   ClearActiveQuests()
   {
      plActiveQuestNodes = $;

      return;
   }

   % This monster is the destination NPC for a questnode
   % Add the node to his list, so he can check completion criteria
   %  when someone enters, says something, or gives him something
   AddQuestNodeToActiveList(node = $)
   {
      if node = $
      {
         Debug("AddQuestNode: nil questnode.");

         return;
      }

      plActiveQuestNodes = Cons(node, plActiveQuestNodes);

      return;
   }
 
   % Remove the questnode from this NPCs list
   RemoveQuestNodeFromActiveList(node = $)
   {
      local iLength, oActiveNode;

      if node = $
      {
         Debug("RemoveQuestNode: nil questnode.");

         return;
      }

      % Save original Length for validation
      iLength = Length( plActiveQuestNodes );

      foreach oActiveNode in plActiveQuestNodes
      {
         if oActiveNode = node
         {
            plActiveQuestNodes = DelListElem(plActiveQuestNodes,oActiveNode);
         }
      }

      % validate that we removed it
      if iLength > Length(plActiveQuestNodes)
      {
         return;
      }

      Debug( "RemoveQuestNode: couldn't find questnode." );

      return;
   }

   TryAddToQuestEngine()
   "Some NPCs should have chatter and random triggers, but should not be "
   "part of the game's quest engine.  This procedure should be overwritten "
   "for them to return FALSE."
   {
      if (viAttributes & MOB_RANDOM) AND (viAttributes & MOB_LISTEN)
      {
         Send(Send(SYS,@GetLibrary),@AddToHinterList,#who=self);
         if (viAttributes & MOB_RECEIVE) OR (viAttributes&MOB_BUYER)
         {
            Send(Send(SYS,@GetLibrary),@AddToQuesterList,#who=self);
         }

         return TRUE;
      }

      return FALSE;
   }

   Delete()
   "End of monster. Clean up any quests it might have spawned."
   {
      local i, j, k;
      % Minion Management - upon dying they should leave your control list
      if poMaster <> $
      {
         Send(poMaster,@RemoveControlledMinion,#what=self);
      }

      % If this monster is an Apparition, tell the original it was deleted.
      if poApparitionOriginal <> $
      {
         Send(poApparitionOriginal,@RemoveApparition,#what=self);
         poApparitionOriginal = $;
         poApparitionCaster = $;
      }

      poEventSpawner = $;
      
      if ptDrowningTimer <> $
      {
         DeleteTimer(ptDrowningTimer);
         ptDrowningTimer = $;
      }
      
      if ptSpellCastTimer <> $
      {
         DeleteTimer(ptSpellCastTimer);
         ptSpellCastTimer = $;
      }
      
      if ptCastingAnimationTimer <> $
      {
         DeleteTimer(ptCastingAnimationTimer);
         ptCastingAnimationTimer = $;
      }

      % Under rare conditions delete is called twice in succession
      if poBrain <> $
      {
         Send(poBrain,@MobDelete,#mob=self,#state=piState);
         poBrain = $;
      }

      Send(self,@ClearBehavior);
      Send(self,@ClearBasicTimers);

      if (viDefault_behavior & AI_NPC) = AI_NPC
      {
         Send(Send(SYS,@GetLibrary),@RemoveNPC,#who=self);
      }

      if (plFor_sale <> $)
      {
         Send(self,@DeleteForSaleList);
      }

      if (viAttributes & MOB_RANDOM)
      {
         Send(Send(SYS,@GetLibrary),@DeleteFromHinterList,#who=self);
         if (viAttributes & MOB_LISTEN)
            AND (viAttributes & MOB_RECEIVE)
         {
            Send(Send(SYS,@GetLibrary),@DeleteFromQuesterList,#who=self);
         }
      }

      Send(Send(SYS,@GetLibrary),@DeleteFromOccupationList,#who=self);

      foreach i in plWantedItems
      {
         if i = &SignetRing
         {
            foreach j in Send(Send(SYS,@GetLibrary),@GetSignetRings)
            {
               if Send(j,@GetRingOwner) = self
                 {
                    Send(Send(SYS,@GetLibrary),@UnregisterSignet,#newring=j);
                    Send(j,@Delete);
                 }
             }
         }
      }

      if ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }

      plMeleeSpellBook = $;
      plRangedSpellBook = $;
      plSelfSpellBook = $;
      plAllySpellBook = $;
      plOtherSpellBook = $;

      Send(self,@RemoveAllEnchantments);
      poMaster = $;
      poHolySymbolCaster = $;
      if ptUnturn <> $
      {
         deleteTimer(ptUnturn);
         ptUnturn = $;
      }

      if ptLoyaltyTimer <> $
      {
         DeleteTimer(ptLoyaltyTimer);
         ptLoyaltyTimer = $;
      }

      poLastAttacker = $;

      propagate;
   }

   % For illusionary form, it makes a bunch of monsters so it can call 'em and
   %  get access to their SendAnimation() things.  To be useful, it needs to
   %  be able to set our piAnimation (to either ANIM_NONE or ANIM_ATTACK, which
   %  work for all monsters).

   SetAnimation(animation = $)
   {
      piAnimation = animation;

      return;
   }

   %%% Enchantments of Monsters

   EnchantmentTimer(timer = $)
   {
      local i;

      foreach i in plEnchantments
      {
         if First(i) = timer
         {
            if Length(i) > ENCHANTMENT_LIST_NO_STATE
            {
               Send(Nth(i,2),@EndEnchantment,#who=self,#state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@EndEnchantment,#who=self);
            }

            plEnchantments = DelListElem(plEnchantments,i);

            return;
         }
      }

      Debug("Enchantment timer went off with no enchantment",timer);

      return;
   }

   StartEnchantment(what = $,time = $,state=$, iSpellPower = 0)
   "Adds <what> to our enchantments, and creates a timer that will cause it "
   "to end."
   {
      local oTimer, lNew_enchantment;

      if time = $ or time = SPELL_INDEFINITE_DURATION 
      {
         oTimer = $;
      }
      else 
      {
         oTimer = CreateTimer(self,@EnchantmentTimer,time);
      }

      if state <> $
      {
         lNew_enchantment = [ oTimer, what, state, iSpellPower ];
      }
      else
      {
         lNew_enchantment = [ oTimer, what, iSpellPower ];
      }

      plEnchantments = Cons(lNew_enchantment,plEnchantments);

      return;
   }

   RemoveAllEnchantments()
   "Remove all current enchantments."
   {
      local i;

      foreach i in plEnchantments
      {
         Send(self,@RemoveEnchantment,#what=Nth(i,2));
      }
      
      foreach i in plRadiusEnchantments
      {
         Send(self,@RemoveRadiusEnchantment,#what=Nth(i,1),#iPower=Nth(i,2),#caster=Nth(i,3));
      }
      
      plRadiusEnchantments = $;

      return;
   }

   RemoveEnchantment(what = $)
   "If have a current enchantment set by <what>, end it."
   {
      local i, state;

      state = $;

      foreach i in plEnchantments
      {
         if Nth(i,2) = what
         {
            if First(i) <> $
            {
               if IsTimer(First(i))
               {
                  DeleteTimer(First(i));
               }
            }
            SetNth(i,1,$);

            if Length(i) > ENCHANTMENT_LIST_NO_STATE
            {
               Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,
                    #state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self);
            }

            plEnchantments = DelListElem(plEnchantments,i); 
         }
      }

      return;
   }

   %%%  State Transition Functions
   
   EnterStateLimbo()
   {
      Send(self,@ClearBehavior);
      
      if poTarget <> $
         AND Send(poTarget,@GetOwner) = poOwner
         AND isClass(poTarget,&User)
      {
         Send(poTarget,@SubtractFromMonsterChasers,
              #level=piAmountAddedToMonsterChasers);
      }

      poTarget = $;
      piHatred = 0;
      Send(self,@SetState,#bit=STATE_LIMBO);
      % The whole point of the limbo state is that there are no timers to set.

      return;
   }

   EnterStateWait(actnow=FALSE,delay=MOB_MOVE_TIMER_WAIT)
   {
      if poTarget <> $
         AND Send(poTarget,@GetOwner) = poOwner
         AND isClass(poTarget,&user)
      {
         Send(poTarget,@SubtractFromMonsterChasers,
              #level=piAmountAddedToMonsterChasers);
      }

      poTarget = $;
      piHatred = 0;

      Send(self,@SetState,#bit=STATE_WAIT);
      Send(self,@ClearBehavior);

      if actnow
      {
         Send(self,@WaitTimer);
      }
      else
      {
         ptBehavior = CreateTimer(self,@WaitTimer,delay);
      }

      return;
   }

   EnterStateMove( actnow=FALSE )
   {
      local iGetTime;
      % Note: All monsters "move" even the ones who physically can't.
      Send(self,@SetState,#bit=STATE_MOVE);

      if poTarget <> $
         AND Send(poTarget,@GetOwner) = poOwner
         AND isClass(poTarget,&User)
      {
         Send(poTarget,@SubtractFromMonsterChasers,
              #level=piAmountAddedToMonsterChasers);
      }

      poTarget = $;
      piHatred = 0;

      Send(self,@ClearBehavior);

      if actnow
      {
         Send(self,@MoveTimer);
      }
      else
      {
         iGetTime = Send(self,@GetMoveTime);
       %  Debug(Send(self,@GetName), " making timer of ", iGetTime, " ms");
         ptBehavior = CreateTimer(self,@MoveTimer,iGetTime);
      }

      return;
   }

   EnterStateAttack(target = $, actnow=TRUE)
   {     
      Send(self,@SetState,#bit=STATE_ATTACK);
      Send(self,@ClearBehavior);
      if actnow
      {
         Send(self,@AttackTimer);
      }
      else
      {
         ptBehavior = CreateTimer(self,@AttackTimer,Send(self,@GetAttackTime));
      }

      return;
   }

   EnterStateChase( target = $, actnow = TRUE )
   {
      if poTarget <> target AND vrSound_aware <> $
      {
         if target <> $
            AND NOT (IsClass(target,&Player)
               AND Send(target,@GetSkillAbility,#skill_num=SKID_HIDE) >= piLevel/2
               AND Send(Send(SYS,@FindSkillByNum,#num=SKID_HIDE),@IsHiding,#who=target))
         {
            if poOwner <> $
            {
               Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=vrSound_aware,
                    #flags=SOUND_RANDOM_PITCH);
            }
            else
            {
               Post(self,@Delete);
            }
         }
      }

      Send(self,@SetState,#bit=STATE_CHASE);
      Send(self,@ClearBehavior);

      if actnow
      {
         Send(self,@ChaseTimer);
      }
      else
      {
         ptBehavior = CreateTimer(self,@ChaseTimer,Send(self,@GetMoveTime));
      }

      return;
   }

   %%% Sensory Inputs
   
   NewOwner(what = $)
   "Monster just entered this room. Right now, thats only possible on a"
   "creation. So, lets pause for a few beats if we got users."
   {
      local iRand, i, iOverrideChampion, iLevelChange, bOverride, bSettingsChampionSpawnEnabled;

      if what = $
      {
         Send(self,@ClearBasicTimers);

         if piChampionStatus <> 0
         {
            Send(self,@LoseChampionStatus);
         }
         
         if ptDrowningTimer <> $
         {
            DeleteTimer(ptDrowningTimer);
            ptDrowningTimer = $;
         }

         propagate;
      }

      % Mobs can change owner, i.e. wanderers. This lets them react properly
      % to leaving a room with users and arriving in a room without them.
      if poOwner <> $
         AND Send(poOwner,@IsUserInRoom)
         AND NOT Send(what,@IsUserInRoom)
      {
         Post(self,@LastUserLeft);
      }

      if Send(what,@IsUserInRoom)
      {
         Send(self,@StartBasicTimers);
      }

      Send(poBrain,@NewOwner,#mob=self,#state=piState,#what=what);
      
      if what <> $
         AND IsClass(what,&ChaosStratumRoom)
         AND NOT (poMaster <> $ AND IsClass(poMaster,&Player))
      {
         if Send(what,@GetMonsterAttackSpeed) > 0
         {
            piAttackSpeed = (piAttackSpeed * (100+Send(what,@GetMonsterAttackSpeed)))/100;
         }
         if Send(what,@GetMonsterMoveSpeed) > 0
         {
            piMoveSpeed = (piMoveSpeed * (100+Send(what,@GetMonsterMoveSpeed)))/100;
         }
      }
      
      if NOT ((piBehavior & AI_NOFIGHT) OR (piBehavior & AI_NPC))
         AND viCanSpawnAsChampion
         AND IsClass(what,&Room)
         AND Send(what,@GetCanSpawnChampions)
         AND Send(SETTINGS_OBJECT,@GetChampionSpawnsEnabled)
         AND Send(self,@GetMaster) = $
         AND NOT pbIllusion
         AND NOT vbSummoned
      {
         iRand = Random(0,9999);
         
         iLevelChange = 0;
         bOverride = FALSE;
         foreach i in Send(what,@GetObjectAttributes)
         {
            if IsClass(i,&RoomThreat)
            {
               iLevelChange = iLevelChange + Send(i,@GetMonsterLevelChange);

               iOverrideChampion = Send(i,@GetOverrideChampion);
               if iOverrideChampion <> 0
               {
                  Post(self,@LoseChampionStatus);
                  Post(self,@GainChampionStatus,#iType=iOverrideChampion);
                  bOverride = TRUE;
               }
            }
         }

         Send(self,@AddLevel,#value=iLevelChange);

         if bOverride
         {
            propagate;
         }
         
         if iRand > 450 AND iRand <= 650
         {
            Post(self,@GainChampionStatus,#iType=CHAMPION_TOUGH);
         }
         
         if iRand > 250 AND iRand <= 450
         {
            Post(self,@GainChampionStatus,#iType=CHAMPION_SWIFT);
         }
         
         if iRand > 50 AND iRand <= 250
         {
            Post(self,@GainChampionStatus,#iType=CHAMPION_DEADLY);
         }
         
         if iRand > 0 AND iRand <= 50
         {
            Post(self,@GainChampionStatus,#iType=CHAMPION_INDOMITABLE);
         }
         
         if iRand = 0
         {
            Post(self,@GainChampionStatus,#iType=CHAMPION_LEGENDARY);
         }
      }
         
      % Do we boost speed?
      if poMaster <> $
         AND IsClass(poMaster,&Player)
         AND NOT Send(self,@IsIllusion)
         AND Send(poMaster,@HasSkill,#num=SKID_MINION_SPEED_BOOST)
      {
         % Give Taskmaster skill a chance to imp.
         Send(Send(SYS,@FindSkillByNum,#num=SKID_MINION_SPEED_BOOST),@ImproveAbility,#who=poMaster);
      }
      
      if vbBreathesAir AND Send(what,@HasAir)
      {
         if ptDrowningTimer <> $
         {
            DeleteTimer(ptDrowningTimer);
            ptDrowningTimer = $;
         }
      }
      else if vbBreathesWater AND Send(what,@IsUnderwater)
      {
         if ptDrowningTimer <> $
         {
            DeleteTimer(ptDrowningTimer);
            ptDrowningTimer = $;
         }
      }
      else
      {
         if ptDrowningTimer = $
         {
            ptDrowningTimer = CreateTimer(self,@DrownDamage,piDrowningDelay);
         }
      }

      propagate;
   }
   
   DrownDamage(timer=$)
   {
      local iDamageResult;

      ptDrowningTimer = $;

      iDamageResult = Send(self,@AssessDamage,#what=self,
                        #damage=piDrowningDamage,
                        #precision=TRUE,
                        #atype=0,
                        #aspell=ATCK_SPELL_DRAIN,#report=FALSE,
                        #bSecondary=TRUE);
      
      if iDamageResult <> $
      {
         ptDrowningTimer = CreateTimer(self,@DrownDamage,piDrowningDelay);
      }
      else
      {
         Send(self,@Killed,#what=poOwner);
      }
      return;
   }

   FirstUserEntered(what = $,new_row = $,new_col = $)
   "Since we've already been notified in SomethingEntered that a user got"
   "here, we have already handled the case that the user was plunked down"
   "near a non-fighting and agressive mob. So, lets just start our timers."
   {
      if ((piState & STATE_LIMBO)
         OR (piBehavior & AI_NPC))
      {
         Send(self,@StartBasicTimers);
      }

      Send(poBrain,@FirstUserEntered,#mob=self,#state=piState,
           #what=what,#new_row=new_row,#new_col=new_col);

      propagate;
   }
   
   LastUserLeft()
   "All our users just left, so lets stop all our timers. If we were a"
   "seller of some conditional goods, we hide them again so the next"
   "set of players has to ask for them by name."
   {
      local i;

      Send(self,@ClearBasicTimers);

      if Send(self,@MobIsCondSeller)
      {
         foreach i in Nth(plFor_sale,4)
         {
            Send(self,@RemoveFromConditionalList,#obj=First(i));
         }
      }

      Send(poBrain,@LastUserLeft,#mob=self,#state=piState);

      propagate;
   }
   
   SomethingMoved(what=$,new_row=$,new_col=$,fine_row=$,fine_col=$)
   "Check to see if we need to change our combat plan because someone moved."
   {
      % If either we or our target moved, then we no longer know 
      %  if the attack is valid.
      if what = self OR what = poTarget
      {
         piState = (piState & VSTATE_VALIDITY_MASK);
      }

      if poBrain <> $
      {
         Send(poBrain,@SomethingMoved,#mob=self,#state=piState,
               #what=what,#new_row=new_row,#new_col=new_col,
               #fine_row=fine_row,#fine_col=fine_col);
      }

      propagate;
   }

   SomethingAttacked(what = $,victim = $,use_weapon = $)
   "We may have been assaulted by something, so lets return fire if "
   "appropriateIf were already fighting this person, this doesnt interrupt "
   "our plans."
   {
      if poBrain <> $
      {
         Send(poBrain,@SomethingAttacked,#mob=self,#state=piState,
               #what=what,#victim=victim,#use_weapon=use_weapon);
      }

      propagate;
   }

   RecordTimeAttacked(who=$)
   "This records the last time the monster was attacked, "
   "and the player or monster that did it."
   {
      local oMaster;

      piLastTimeAttacked = GetTime();

      if who <> $
      {
         if IsClass(who,&Monster)
         {
            % Check if the monster has a master. If so, use the master here.
            oMaster = Send(who,@GetMaster);
            if oMaster <> $
            {
               who = oMaster;
            }
         }
      }
      poLastAttacker = who;

      return;
   }

   GetTimeAttacked()
   {
      return piLastTimeAttacked;
   }

   RecordTimeCasted()
   "This records the last time the monster cast a spell."
   {
      ptSpellCastTimer = CreateTimer(self,@SpellCastTimer,piMonsterCastDelayMinimum);

      return;
   }
   
   SpellCastTimer(timer=$)
   {
      ptSpellCastTimer = $;
      return;
   }

   GetLastAttacker()
   {
      return poLastAttacker;
   }

   PlayerFirstMove(what=$, where = $, new_row = 0, new_col=0)
   {
      Send(poBrain,@PlayerFirstMove,#mob=self,#state=piState,
           #what=what,#where=where,#new_row = new_row, #new_col=new_col);

      return;
   }

   SomethingEntered(what = $,where=$)
   "If we're not fighting, and the person is right near us, lets reset our "
   "timers so we dont attack unless we're attacked for the first few seconds "
   "This means that chasing mobs will get reset too, but we dont want em to "
   "hit someome in a room transition."
   {
      local oQuestNode;

      Send(poBrain,@SomethingEntered,#mob=self,#state=piState,
           #what=what,#where=where);

      % If there are active quest nodes, notify them -AJM
      if plActiveQuestNodes <> $
      {
         % make sure it's a player who entered
         if IsClass(what,&Player)
         {
            foreach oQuestNode in plActiveQuestNodes
            {
               if Send(oQuestNode,@CheckCompletionCriteria,#who_tried=what)
               {
                  return;
               }
            }
         }
      } 

      propagate;
   }

   SomethingLeft(what = $, iRow=0, iCol=0)
   "We lost someone, perhaps we need to clear our targets."
   {
      % Our master may have left.  If he did, and he is close by,
      % teleport after him.
      if poMaster <> $ AND what = poMaster
      {
         if iRow <> 0 AND iCol <> 0
            AND Send(poMaster,@GetOwner) <> $
         {
            Post(self,@GotoMaster);
         }

         % Seduced minions and dragonfly queens are loyal,
         % but anything else is set free if the master logs off
         if NOT IsClass(self,&DragonFlyQueen)
            AND NOT Send(self,@IsEnchanted,#byClass=&Seduce)
         {
            if IsClass(poMaster,&Player)
               AND NOT Send(poMaster,@IsLoggedOn)
            {
               Send(poMaster,@SaveMinionOnLogoff,#oMonster=self);
               % Send this rather than post, otherwise the master's
               % piMonsterChasers isn't updated properly.
               Send(self,@SetMaster,#oMaster=$);
               Post(self,@Delete);
            }
         }
      }
      if poBrain <> $
      {
         Send(poBrain,@SomethingLeft,#mob=self,#state=piState,#what=what);
      }

      propagate;
   }

   GotoMaster()
   {
      local oNewRoom;

      if poMaster = $
      {
         return;
      }

      oNewRoom = Send(poMaster,@GetOwner);
      if oNewRoom = $
      {
         return;
      }

      if (Send(oNewRoom,@CountMonsters,#mastered=TRUE) < 50)
      {
         Send(oNewRoom,@NewHold,#what=self,
               #new_row=Send(poMaster,@GetRow),#new_col=Send(poMaster,@GetCol),
               #fine_row=Send(poMaster,@GetFineRow),#fine_col=Send(poMaster,@GetFineCol),
               #new_angle=Send(poMaster,@GetAngle));
      }

      return;
   }

   SomethingKilled(what = $,victim = $,use_weapon = $)
   "Someone just died, perhaps we need to clear our target."
   {
      Send(poBrain,@SomethingKilled,#mob=self,#state=piState,
           #what=what,#victim=victim,#use_weapon=use_weapon);

      propagate;
   }

   %%% New Utility Routines

   OfferSubtractNumberItems()
   "filler because some junk in user.kod assumes everyone has this"
   {
      return;
   }

   GetTarget()
   {
      return poTarget;
   }

   GetCustomer()
   {
      return poCustomer;
   }

   CanPatrol()
   {
      if (plPatrolPath <> $)
      {
         return TRUE;
      }

      return FALSE;
   }

   GetChanceToPatrol()
   {
      return piChanceToPatrol;
   }

   SetChanceToPatrol(chance=125)
   {
      piChanceToPatrol = chance;

      return;
   }

   GetNextPatrolNode()
   {
      if (plPatrolPath = $)
      {
         return;
      }

      piPatrolNode = piPatrolNode + 1;

      if (piPatrolNode > Length(plPatrolPath))
      {
         if (piBehavior & AI_LOOPING_PATROL)
         {
            piPatrolNode = 1;
         }
         else
         {
            piPatrolNode = Length(plPatrolPath);
         }
      }

      return Nth(plPatrolPath, piPatrolNode);
   }

   SetPatrolNode(node=1)
   {
      piPatrolNode = node;

      return;
   }

   IncrementPatrolAttempts()
   {
      piPatrolAttempts = piPatrolAttempts + 1;

      return;
   }

   GetPatrolAttempts()
   {
      return piPatrolAttempts;
   }

   ClearPatrolAttempts()
   {
      piPatrolAttempts = 0;

      return;
   }

   ClearPatrolLocation()
   {
      Send(self,@SetBehaviorFlag,#flag=AI_HAS_TARGET_LOCATION,#value=FALSE);
      piTargetLocationRow  = 0;
      piTargetLocationCol  = 0;
      piTargetLocationFineRow = 0;
      piTargetLocationFineCol = 0;

      return;
   }

   %%%  Action Routines

   AttackTimer(timer = $)
   "We were bashing on something before, and now its time to hit it again."
   {
      Send(self,@ClearBehavior,#timer=timer);

      % sanity checks
      if poOwner = $
      {
         %Debug("Unreachable. Null Owner");
         Send(self,@EnterStateLimbo);

         return;
      }

      if poTarget = $ OR NOT IsClass(poTarget,&Battler)
      {
         %Debug("Unreachable. Null poTarget","monster",self);
         poTarget = $;
         Send(self,@EnterStateWait);

         return;
      }

      % Victim phased out, is now in spectator mode, or hiding, break aggro.
      if IsClass(poTarget,&User)
         AND (Send(poTarget,@IsInCannotInteractMode)
             OR (Send(poTarget,@GetSkillAbility,#skill_num=SKID_HIDE) >= piLevel/2
               AND Send(Send(SYS,@FindSkillByNum,#num=SKID_HIDE),@IsHiding,#who=poTarget)))
      {
         Send(self,@EnterStateMove);

         return;
      }

      Send(poBrain,@GetAttackBehavior,#mob=self,#target=poTarget,
           #behavior=piBehavior);
      
      if poTarget = $
      {
         Send(self,@EnterStateMove);

         return;
      }      

      if NOT Send(self,@CanReach,#what=poTarget) 
      {         
         Send(self,@EnterStateChase);

         return;
      }

      % We're close enough and in range.  Now, normally, we move 
      %  around the player to keep him guessing.   Let's zigzag around,
      %  instead of consistently moving to that player's right.
      if random(1,100) < 50
      {
         piState = piState | ESTATE_CLOCKWISE;
      }
      else
      {
         piState = piState & ESTATE_CCLK_MASK;
      }

      % Are we attacking or casting a melee spell?
      if NOT (Send(self,@MonsterCanCastSpell)
            AND (Random(1,100) <= piMeleeSpellChance OR (poTarget <> $ AND Send(poTarget,@IsEnchanted,#byClass=&MarkOfMagic)))
            AND NOT (poTarget <> $ AND Send(poTarget,@IsEnchanted,#byClass=&MarkOfAggression))
            AND Send(self,@AttemptSpell,#type=CAST_TYPE_MELEE))
      {
         % AttemptSpell returns TRUE if everything works out. If not, we attack.
         Send(self,@TryAttack,#what=poTarget,#stroke_obj=self);
      }
      
      % Sanity check, in rare occurrences mob dies before this can execute 
      if poBrain <> $
      {
         Send(poBrain,@PostAttackTimer,#mob=self,#state=piState);
      }

      return;
   }

   QueueSpellType(type=CAST_TYPE_ALLY)
   {
      piQueuedSpellType = type;
      return;
   }
   
   AttemptSpell(type=CAST_TYPE_MELEE)
   {
      local lSpell, oSpell, iSpellPower, oAntiMagicAura, lRadiusState, iDistance, lTargets, iRange, oTarget;
      
      if poTarget = $
         AND (type = CAST_TYPE_MELEE
            OR type = CAST_TYPE_RANGED)
      {
         % Why are we casting offensively if we have no enemy?
         return FALSE;
      }
      
      if (type = CAST_TYPE_MELEE
         OR type = CAST_TYPE_RANGED)
            AND piQueuedSpellType <> 0
      {
         type = piQueuedSpellType;
         piQueuedSpellType = 0;
      }
      
      lSpell = Send(self,@PickSpell,#type=type);
      
      if type = CAST_TYPE_ALLY
         AND poMaster <> $
      {
         oTarget = poMaster;
      }
      else
      {
         oTarget = poTarget;
         
         if poMaster <> $
            AND IsClass(poMaster,&Player)
         {
            if NOT Send(poMaster,@AllowPlayerAttack,#victim=oTarget,#report=FALSE,#actual=FALSE)
            {
               % No casting offensive spells on things player master can't attack
               return FALSE;
            }
         }
      }

      if lSpell <> $
         AND piMana >= Nth(lSpell,2)
         AND oTarget <> $
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=Nth(lSpell,1));
         if oSpell <> $
         {
            if Length(lSpell) > 3
            {
               iSpellPower = Send(self,@GetSpellPower,#base_power=Nth(lSpell,4),#oSpell=oSpell);
            }
            else
            {
               iSpellPower = Send(self,@GetSpellPower,#base_power=Random(1,99),#oSpell=oSpell);
            }

            % Get distance to target.
            iDistance = Send(self,@SquaredFineDistanceTo3D,#what=oTarget);

            % Check LoS to target here so we don't waste mana casting
            % when we can't get our target.

            iRange = Send(oSpell,@GetRange);
            if iRange = $
            {
               iRange = 9999;
            }
            if iDistance <= iRange * iRange
               AND Send(poOwner,@LineOfSight,#obj1=self,#obj2=oTarget)
               AND Send(poOwner,@ReqSomethingAttack,#what=self,#victim=oTarget,
                        #use_weapon=self)
            {
               piMana = piMana - Nth(lSpell,2);
               Send(self,@NewMana);
         
               % Find the valid targets.
               lTargets = [oTarget];
               lTargets = Send(oSpell,@GetTargets,#who=self,#lTargets=lTargets);

               % See if we can cast the spell here.
               if Send(oSpell,@CanPayMonsterCosts,#who=self,#lTargets=lTargets,
                        #iSpellPower=iSpellPower)
                  AND Send(poOwner,@ReqSpellCast,#who=self,#oSpell=oSpell,
                           #lItems=lTargets)
               {
                  % Do any special cast animations; send spell for specific ones.
                  Send(self,@MonsterCastAnimation,#iSpellNum=Send(oSpell,@GetSpellNum));

                  % Cast the spell.
                  Send(oSpell,@CastSpell,#who=self,#lTargets=lTargets,
                        #iSpellPower=iSpellPower);
               }

               Send(self,@RecordTimeCasted);
               return TRUE;
            }
         }
      }

      return FALSE;
   }

   GetSpellPower(base_power=0, oSpell=$, lTargets=$)
   {
      local iSpellPower, i, iTerrain, oRoom, oModifierSpell, iAbilityLoss,
            iAbilityGain, iItemModifier, iBase, iPrimaryBonus, iSecondaryBonus,
            iPowerBonus, iShrines, lRadiusState, iSchool;

      if oSpell = $
      {
         return SPELLPOWER_MINIMUM;
      }

      oRoom = Send(self,@GetOwner);  

      % Check the monster's in use items to see if they affect anything.
      % Note that this also checks itematts.
      iItemModifier = 0;
      foreach i in Send(self,@GetPlayerUsing)
      {
         iItemModifier = iItemModifier + Send(i,@GetSpellModifier,
                                              #oSpell=oSpell);
      }
   
      % Each school has a bonus for different things.
      iPrimaryBonus = 0;
      iSecondaryBonus = 0;

      iSchool = Send(oSpell,@GetSchool);
      if iSchool = SS_SHALILLE
      {
         % Shal'ille gives bonuses depending on the room setting,
         %  prefers natural settings.
         iPrimaryBonus = Send(oRoom,@GetShalilleBonus);
         % Secondary bonus based on Karma.
         iSecondaryBonus = abs(Send(self,@GetKarma)/10);

         % Forces of Light boosts Shal'ille
         if Send(oRoom,@IsEnchanted,#what=SID_FORCES_OF_LIGHT)
         {
            % Add a function of the spellpower.
            iAbilityGain = Send(oRoom,@GetEnchantmentState,
                                 #what=SID_FORCES_OF_LIGHT);
            iAbilityGain = iAbilityGain/10;
            iSecondaryBonus = iSecondaryBonus + iAbilityGain;
         }
      }
      
      if iSchool = SS_QOR
      {
         % Qor strength determined by day or night.
         iPrimaryBonus =  (2 + Send(SYS,@GetHour));
         % Secondary bonus comes from Karma.
         iSecondaryBonus = abs(Send(self,@GetKarma)/10);

         % Darkness boosts Qor
         if Send(oRoom,@IsEnchanted,#what=SID_DARKNESS)
         {
            % This reconstructs the darkness spellpower.
            iAbilityGain = Send(oRoom,@GetEnchantmentState,
                                 #what=SID_DARKNESS);
            iAbilityGain = -(iAbilityGain - 25);
            iAbilityGain = iAbilityGain/10;
            iSecondaryBonus = iSecondaryBonus + iAbilityGain;
         }
      }
      
      if iSchool = SS_RIIJA
      {
         % Riija's bonuses are a bit random seeming.
         % Riija strength determined by moon position - range is -16 to 30
         foreach i in Send(SYS,@GetBackgroundObjects)
         {
            if IsClass(i,&Moon)  
            {
               iPrimaryBonus = Send(i,@GetBackgroundOverlayHeight)/12;
            }
         }

         % Riija's secondary bonus depends on the number of items you're holding.
         iSecondaryBonus = 10;
      }
      
      if iSchool = SS_FAREN
      {
         % Faren prefers water and fire.  If he finds water and fire, he gets stronger.
         iPrimaryBonus = Send(oRoom,@GetFarenBonus);
         % Faren also rewards the vigorous warrior.
         iSecondaryBonus = Send(self,@GetHealth)/Send(self,@GetMaxHealth);
      }
      
      if iSchool = SS_KRAANAN
      {
         % Kraanan favors adversity and armies.  More people in a room, the better.
         iPrimaryBonus = Length(Send(oRoom,@GetHolderActive));
         % Kraanan also favors the healthy warrior.  Full hps = more bonus.
         iSecondaryBonus = ((Send(self,@GetHealth)*100)/Send(self,@GetMaxHealth))/10;
      }
      
      if iSchool = SS_JALA
      {
         iSecondaryBonus = Send(self,@GetMaxHealth)/12;
      }

      % Bind the bonuses to reasonable values.
      if iSchool <> SS_JALA
      {
         iPrimaryBonus = bound(iPrimaryBonus,0,30);
      }
      iSecondaryBonus = bound(iSecondaryBonus,0,10);

      iSpellPower = iPrimaryBonus + iSecondaryBonus + base_power;

      lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,#byClass=&AntiMagicAura);
      if lRadiusState <> $
      {
         iSpellPower = Send(Nth(lRadiusState,1),@ModifySpellpower,#who=self,#oSpell=oSpell,#state=lRadiusState,#iSpellPower=iSpellPower);
      }

      lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,#byClass=&ManaConvergence);
      if lRadiusState <> $
      {
         iSpellPower = Send(Nth(lRadiusState,1),@ModifySpellpower,#who=self,#oSpell=oSpell,#state=lRadiusState,#iSpellPower=iSpellPower);
      }

      % Bound the lower end so that the stuff that follows is truly a bonus.
      iSpellPower = bound(iSpellPower,0,$);

      % This number is based on the number of shrines this god controls.
      iShrines = Send(SYS,@GetShrineBonus,#school=iSchool);

      % These bonuses (shrine, items) can boost spell power after all other modifiers.
      iSpellPower = iSpellPower + iShrines + iItemModifier;

      % Then, add bonus from the system object, set by admins
      iSpellPower = iSpellPower + Send(SYS,@GetBonusSpellpower,#school=iSchool);

      % Affected by the Dement spell?
      oModifierSpell = Send(SYS,@FindSpellByNum,#num=SID_DEMENT);
      if Send(self,@IsEnchanted,#what=oModifierSpell)
      {
         iAbilityLoss = 34;
         iAbilityLoss = Random(iAbilityLoss, iAbilityLoss*2);
         iSpellpower = iSpellpower - iAbilityLoss;
      }

      % Bound the result.
      iSpellPower = bound(iSpellPower,SPELLPOWER_MINIMUM,SPELLPOWER_MAXIMUM);

      return iSpellPower;
   }

   PickSpell(type=CAST_TYPE_MELEE)
   {
      local iRandom, lSpell;

      iRandom = Random(1,100);

      % [ Spell num, mana cost, number req. from Random(1,100) to cast ]
      if type = CAST_TYPE_MELEE
      {
         foreach lSpell in plMeleeSpellBook
         {
            if iRandom <= Nth(lSpell,3)
            {
               return lSpell;
            }
         }
      }
      if type = CAST_TYPE_RANGED
      {
         foreach lSpell in plRangedSpellBook
         {
            if iRandom <= Nth(lSpell,3)
            {
               return lSpell;
            }
         }
      }
      if type = CAST_TYPE_SELF
      {
         foreach lSpell in plSelfSpellBook
         {
            if iRandom <= Nth(lSpell,3)
            {
               return lSpell;
            }
         }
      }
      if type = CAST_TYPE_ALLY
      {
         foreach lSpell in plAllySpellBook
         {
            if iRandom <= Nth(lSpell,3)
            {
               return lSpell;
            }
         }
      }
      if type = CAST_TYPE_OTHER
      {
         foreach lSpell in plOtherSpellBook
         {
            if iRandom <= Nth(lSpell,3)
            {
               return lSpell;
            }
         }
      }
      
      return $;
   }

   ChaseTimer( timer = $ )
   "We're in Hot pursuit, so either we keep chasing, or we attack."
   "Note that even if we can't move, we can be 'chasing'...."
   {
      local i,oVictim,iVision,each_obj,iCount, bCast;
      oVictim = poTarget;

      Send(self,@ClearBehavior,#timer=timer);

      % Sanity checks
      if poOwner = $
      {
         % Suppress survival mob messages. Happens sometimes.
         if piBoostedLevel = 0
         {
            Debug("Unreachable. Null owner.");
            Debug(self);
         }
         Send(self,@EnterStateLimbo);
         Post(self,@Delete);

         return;
      }

      % If target left, we should already know
      if oVictim = $
      {
         %Debug("Unreachable. Null victim.");
         Send(self,@EnterStateWait);

         return;
      }
      
      % Sometimes we don't know if target left, however.
      if Send(oVictim,@GetOwner) <> Send(self,@GetOwner)
      {
         Send(self,@EnterStateWait);
         return;
      }

      % Victim phased out, is now in spectator mode, or hiding, break aggro.
      if IsClass(oVictim,&User)
         AND (Send(oVictim,@IsInCannotInteractMode)
             OR (Send(oVictim,@GetSkillAbility,#skill_num=SKID_HIDE) >= piLevel/2
               AND Send(Send(SYS,@FindSkillByNum,#num=SKID_HIDE),@IsHiding,#who=oVictim)))
      {
         Send(self,@EnterStateMove);

         return;
      }

      % If we moved into range last cycle, we will switch to attack mode
      if Send(poBrain,@PreChaseTimer,#mob=self)
      {
         return;
      }

      % Perhaps we heal this chase moment.
      if piHit_points < piMax_hit_points*100 AND Random(1,Bound(piMoveSpeed,8,$)) = 1
      {
         Send(self,@HealHitPoint);
      }

      bCast = FALSE;
      if Send(self,@MonsterCanCastSpell)
         AND (Random(1,100) <= piRangedSpellChance OR (poTarget <> $ AND Send(poTarget,@IsEnchanted,#byClass=&MarkOfMagic)))
         AND NOT (poTarget <> $ AND Send(poTarget,@IsEnchanted,#byClass=&MarkOfAggression))
      {
         bCast = Send(self,@AttemptSpell,#type=CAST_TYPE_RANGED);
      }
      
      if NOT bCast
         AND vbHasRangedAttack
      {
         bCast = Send(self,@AttemptRangedAttack);
      }

      % If we can move, we physically try to get closer
      if not bCast
      {
         Send(poBrain,@GetChaseBehavior,#mob=self,#target=poTarget,
              #behavior=piBehavior);
      }

      % Call this if the monster just killed the player with a spell
      if poTarget <> $
      {
         Send(poBrain,@PostChaseTimer,#mob=self);
      }
      else
      {
         % Monster slung a spell, killed player
         Send(self,@EnterStateMove);      
      }

      return;
   }

   AttemptRangedAttack()
   {
      local iBase;

      iBase = Send(self,@RangedAttackChance,#base=(viRangedAttackChance*6));

      if Random(1,iBase) = 1
         AND Send(self,@SquaredFineDistanceTo3D,#what=poTarget) < viRangedAttackRange * viRangedAttackRange
         AND Send(poOwner,@LineOfSight,#obj1=self,#obj2=poTarget)
         AND Send(poOwner,@ReqSomethingAttack,#what=self,#victim=poTarget,#use_weapon=self)
         AND ptSpellCastTimer = $
      {
         Send(self,@DoMissileAttack);

         return TRUE;
      }

      return FALSE;
   }

   DoMissileAttack()
   {
      Send(poOwner,@SomethingShot,#who=self,#target=poTarget,#projectile=self);
      if Send(self,@TryAttack,#what=poTarget,#stroke_obj=self)
      {
         Send(self,@RecordTimeCasted);
      }

      return;
   }

   MoveTimer( timer = $ )
   "Time to move a notch. I would REALLY like it to redo this so that the "
   "Monsters move on a finer grid than the row/col (perhaps 16finerow?) "
   "But just havent had the time. Anyway, we want to wander unless for "
   "some reason we are restricted not to. We do check to see if there is "
   "someone to chase if we are the agressive type. If we cant physically "
   "move, then we still keep the timer open for its healing/etc."
   {
      Send(self,@ClearBehavior,#timer=timer);

      % Sanity checks
      if poOwner = $
         OR NOT IsClass(poOwner,&Room)
         OR (IsClass(poOwner,&Room)
             AND NOT Send(poOwner,@IsUserInRoom))
      {
         Send(self,@EnterStateLimbo);

         return;
      }

      % Perhaps we heal this movement tick.
      if piHit_points < piMax_hit_points*100 AND Random(1,Bound(piMoveSpeed,8,$)) = 1
      {
         Send(self,@HealHitPoint);
      }

      % Okay, ask our brain how to move
      Send(poBrain,@GetMoveBehavior,#behavior=piBehavior,#mob=self);

      % See if we want to change state now, but check for brain here first.
      % Sometimes we've died by now.
      if poBrain <> $
      {
         Send(poBrain,@PostMoveTimer,#mob=self);
      }

      return;
   }

   WaitTimer( timer = $ )
   {
      Send(self,@ClearBehavior,#timer=timer);
      Send(poBrain,@PostWaitTimer,#mob=self);

      return;
   }

   %%%  Spell Support

   ResetBehaviorFlags()
   "This starts with the default brain, and then goes through "
   "all the enchantments on a monster, tweaking flags as we go."
   "Note that this can be called both at the start and the end "
   "of an enchantment or behavior change."
   {
      local i, lBehavior;

      lBehavior = $;

      % Assume if the monster is being singleminded about something,
      %  he's got a good reason.  Example: pissed off charms.
      if piBehavior & AI_FIGHT_SINGLEMINDED
      {
         lBehavior = Cons(AI_FIGHT_SINGLEMINDED,lBehavior);
      }
      if piBehavior & AI_MOVE_WHEN_ALONE
      {
         lBehavior = Cons(AI_MOVE_WHEN_ALONE,lBehavior);
      }
      if piBehavior & AI_CAN_PATROL
      {
         lBehavior = Cons(AI_CAN_PATROL,lBehavior);
      }
      if piBehavior & AI_HAS_TARGET_LOCATION
      {
         lBehavior = Cons(AI_HAS_TARGET_LOCATION,lBehavior);
      }
      if piBehavior & AI_LOOPING_PATROL
      {
         lBehavior = Cons(AI_LOOPING_PATROL,lBehavior);
      }

      piBehavior = viDefault_behavior;

      foreach i in lBehavior
      {
         Send(self,@SetBehaviorFlag,#flag=i);
      }

      foreach i in plEnchantments
      {
         Send(Nth(i,2),@ModifyMonsterBehavior,#mob=self);
      }

      % This is for monster specific things, such as the dragonfly queen
      %  being charmed.  We need to do this after we set defaultbehavior,
      %  so this goes here.  Monsters shouldn't need to overwrite
      %  ResetBehaviorFlags, but they are encouraged to overwrite
      %  TweakBehavior.  see monster\dflyq.kod.
      Send(self,@TweakBehavior);

      return;
   }

   TweakBehavior()
   {
      return;
   }

   GetBehavior()
   {
      return piBehavior;
   }

   AddMonsterAim(points=0)
   {
      local iOrigAim;

      iOrigAim = piAim;
      piAim = piAim + points;
      piAim = Bound(piAim,1,50);

      return piAim - iOrigAim;
   }

   AddMonsterAgility(points=0)
   {
      local iOrigAgil;

      iOrigAgil = piAgility;
      piAgility = piAgility + points;
      piAgility = Bound(piAgility,1,50);

      return piAgility - iOrigAgil;
   }

   StartPalsy()
   {
      piEnch_flags = (piEnch_flags | ENCH_PALSY);

      return;
   }

   EndPalsy()
   {
      piEnch_flags = (piEnch_flags & ~ENCH_PALSY);

      return;
   }
   
   StartDementia()
   {
      piEnch_flags = (piEnch_flags | ENCH_DEMENTIA);

      return;
   }

   EndDementia()
   {
      piEnch_flags = (piEnch_flags & ~ENCH_DEMENTIA);

      return;
   }

   AdjustedChanceBase(base = 0)
   "Adjusts the probability of a monster spell cast based on enchantments"
   {
      local oSpell;

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_ANTIMAGIC_AURA);
      if Send(poOwner,@CheckRoomFlag,#flag=ROOM_ANTI_MAGIC)
         AND (Send(poOwner,@GetEnchantmentState,#what=oSpell) <> $)
      {
         % Reduce chance to 2/3 by multplying base by 3/2
         base = (3 * base) / 2;
      }

      if (piEnch_flags & ENCH_DEMENTIA)
      {
         % Halve the chance by doubling the base
         base = base * 2;
      }

      return base;
   }

   RangedAttackChance(base=0)
   {
      if Send(self,@IsEnchanted,#byClass=&Vertigo)
      {
         base = base + 18;
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Winds)
      {
         base = base + 24;
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Sandstorm)
      {
         base = base + 30;
      }

      return base;
   }

   %%%  Auxiliary Routines

   DoRandomWalk(override=FALSE)
   {
      local iNew_row, iNew_col, iNew_finerow, iNew_finecol;

      % The bigger/tougher I am, the less likely I'm interested in milling
      %  around.
      if Random(1,140) < piHit_points/100
         AND NOT override
      {
         return;
      }
      
      % start with old coordinates
      iNew_row = piRow;
      iNew_col = piCol;
      iNew_finerow = piFine_row;
      iNew_finecol = piFine_col;

      % make a random highres-step in one of 4 directions
      if Random(0,1) = 0
      {
         if (Random(0,1) = 0)
         {
            iNew_finerow = iNew_finerow + 16;
         }
         else
         {
            iNew_finerow = iNew_finerow - 16;
         }
      }
      else
      {
         if (Random(0,1) = 0)
         {
            iNew_finecol = iNew_finecol + 16;
         }
         else
         {
            iNew_finecol = iNew_finecol - 16;
         }
      }

      % moved down at least a full row 
      if iNew_finerow >= FINENESS
      {
         iNew_row = piRow + (iNew_finerow / FINENESS);
         iNew_finerow = iNew_finerow MOD FINENESS;
      }
      else if iNew_finerow < 0
      {
         % moved up at least a full row
         iNew_row = piRow - bound((-iNew_finerow / FINENESS), 1, 100);
         iNew_finerow = FINENESS - (-iNew_finerow MOD FINENESS);
      }
     
      % moved right at least a full col 
      if iNew_finecol >= FINENESS
      {
         iNew_col = piCol + (iNew_finecol / FINENESS);
         iNew_finecol = iNew_finecol MOD FINENESS;
      }
      else if iNew_finecol < 0
      {
         % moved left at least a full row
         iNew_col = piCol - bound((-iNew_finecol / FINENESS), 1, 100);
         iNew_finecol = FINENESS - (-iNew_finecol MOD FINENESS);
      }

      if (NOT (piBehavior & AI_MOVE_WALKTHROUGH_WALLS))
         OR Send(self,@ReqMonsterMove,#new_row=iNew_row,#new_col=iNew_col,
                  #new_finerow=iNew_finerow,#new_finecol=iNew_finecol)
      {
         Send(self,@MonsterOrient,#new_row=iNew_row,#new_col=iNew_col,
              #new_finerow=iNew_finerow,#new_finecol=iNew_finecol);

         % Check for owner, perhaps we died already
         if poOwner <> $
         {
            if Send(poOwner,@ReqSomethingMoved,#what=self,
                     #new_row=iNew_row,#new_col=iNew_col,
                     #new_finerow=iNew_finerow,#new_finecol=iNew_finecol,
                     #server_validate=(NOT(piBehavior&AI_MOVE_WALKTHROUGH_WALLS)))
            {
               Send(poOwner,@SomethingMoved,#what=self,
                     #new_row=iNew_row,#new_col=iNew_col,
                     #fine_row=iNew_finerow,#fine_col=iNew_finecol,
                     #speed=(0x80|piMoveSpeed),#non_monsters_only=TRUE);
            }
         }
      }

      return;
   }

   MoveToMaster()
   {
      local drow, dcol, iCloseToMasterRange;

      if poMaster = $
      {
         Debug("MovetoMaster Called with nil master!",Send(self,@GetName));
         return;
      }

      % calculate distance in highres-grid squares (steps we can still make)
      drow = ((Send(poMaster,@GetRow) * FINENESS) + Send(poMaster,@GetFineRow)) / 16;
      dcol = ((Send(poMaster,@GetCol) * FINENESS) + Send(poMaster,@GetFineCol)) / 16;
      drow = abs(drow - (((piRow * FINENESS) + piFine_row) / 16));
      dcol = abs(dcol - (((piCol * FINENESS) + piFine_col) / 16));

      if Send(poMaster,@GetControlledMinions) <> $
         AND Length(Send(poMaster,@GetControlledMinions)) > 6
      {
         % Expand the range that constitutes 'close to master' if we have excessive minions
         iCloseToMasterRange = 5;
      }
      else
      {
         iCloseToMasterRange = 3;
      }

      % Try step closer to the master, if we're not yet close enough.
      % The move-timer is configured to make this movement seamless.
      if drow > iCloseToMasterRange OR dcol > iCloseToMasterRange
      {
        Send(self,@MoveTowards,#oTarget=poMaster,#face_target=TRUE);
      }
      else if piKeepWalkingSteps < 8
      {
         % If we're close, we start a move around the master based on a probability.
         % To do so we just need to try to step closer, he will block us.
         % We will do 8 seamless steps, before we again decide
         % to stop or to go on.
            Send(self,@MoveTowards,#oTarget=poMaster,#face_target=TRUE);
            piKeepWalkingSteps = piKeepWalkingSteps + 1;
      }
      else if Random(1,2000) < 5
      {
         % roll a dice to see if we want to start a new movement
         piKeepWalkingSteps = 0;
      }

      return;
   }

   DoGoTowardsLocation()
   {
      local iDist2;

      % see how far away we are (2D only)
      iDist2 = Send(self, @SquaredFineDistanceToLocation,
                    #row=piTargetLocationRow,
                    #col=piTargetLocationCol,
                    #fine_row=piTargetLocationFineRow,
                    #fine_col=piTargetLocationFineCol);

      % more than 64 fine-units far away (64*64=4096)
      % and not yet reached maxappempts
      if iDist2 > 4096 AND piPatrolAttempts < 500
      {
         % try get closer
         Send(self,@MoveTowardsCoords,
              #iRow=piTargetLocationRow,
              #iCol=piTargetLocationCol,
              #iFineRow=piTargetLocationFineRow,
              #iFineCol=piTargetLocationFineCol);

         piPatrolAttempts = piPatrolAttempts + 1;
      }
      else
      {
         % close enough
         Send(self,@SetBehaviorFlag,#flag=AI_HAS_TARGET_LOCATION,#value=FALSE);
         piPatrolAttempts = 0;
      }
 
      return;
   }

   StartNextPatrolLeg()
   {
      local lPatrolNode;

      lPatrolNode = Send(self,@GetNextPatrolNode);

      if (lPatrolNode <> $)
      {
         Send(self,@GotoCoords,#iRow=First(lPatrolNode),#iCol=Nth(lPatrolNode,2));
      }

      return;
   }

   %%% Combat messages

   TryAttack(what=$,stroke_obj=$)
   "Ok, we got someone to attack, lets try and hit them."
   {
      local bWasBad, lMinions;

      %% okay, NPCs and NOFIGHT mobs can't attack
      if (piBehavior & AI_NOFIGHT) OR (piBehavior & AI_NPC)
      {
         return FALSE;
      }

      % Phased players can't be hit.
      % Jig prevents combat between players and monsters.
      if IsClass(what,&User)
         AND Send(what,@IsInCannotInteractMode)
         OR Send(what,@IsAffectedByRadiusEnchantment,#byClass=&Jig)
      {
         return FALSE;
      }

      % Make sure room allows the attack.
      if NOT Send(poOwner,@ReqSomethingAttack,#what=self,#victim=what,
                  #stroke_obj=stroke_obj)
      {
         % Check if room has special combat effects.
         return FALSE;
      }

      % If we're hitting another monster, check if we can reach or attack it.
      if IsClass(what,&Monster)
      {
         if NOT Send(what,@CanMonsterFight,#who=self,#oStroke=stroke_obj,
                     #use_weapon=stroke_obj)
         {
            return FALSE;
         }
      }

      % Minions are attacking for a master. Handle ETs, Reflections,
      % Seduced and Animated monsters here. If the master can't attack,
      % we can't either. If they can, we treat it as if they personally
      % attacked the target.
      
      if IsClass(what,&Monster)
         AND Send(what,@GetMaster) <> $
         AND IsClass(Send(what,@GetMaster),&Player)
         AND Send(Send(what,@GetMaster),@IsInCannotInteractMode)
      {
         % Monsters whose masters are phased out cannot be attacked
         return FALSE;
      }

      if poMaster <> $
         AND IsClass(poMaster,&Player)
      {
         % Check the attack here. If it fails, AllowPlayerAttack handles
         % the message sent to the player.
         if NOT Send(poMaster,@AllowPlayerAttack,#victim=what,#report=FALSE)
         {
            return FALSE;
         }

         % Don't attack other minions of the caster, or (if we're a reflection)
         % the caster himself. Other minions can attack the caster, to prevent
         % Seducing something just to kill it.
         lMinions = Send(poMaster,@GetControlledMinions);
         if (lMinions <> $
               AND FindListElem(lMinions,what))
            OR (IsClass(self,&Reflection)
               AND what = poMaster)
         {
            return FALSE;
         }
         
         % Don't attack things being charmed.
         if Send(what,@GetStatusEffect,#type=STATUS_CHARMED)
         {
            return FALSE;
         }

         % Is the caster bad to start with? This is for flavor text.
         bWasBad = (Send(poMaster,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
                    OR Send(poMaster,@CheckPlayerFlag,#flag=PFLAG_MURDERER));
         % If they weren't bad and become bad, let them know.
         if NOT bWasBad
            AND (Send(poMaster,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               OR Send(poMaster,@CheckPlayerFlag,#flag=PFLAG_MURDERER))
         {
            Send(poMaster,@MsgSendUser,#message_rsc=vrMinion_trouble);
         }
      }

      % If we have minions, see if they can attack too
      Send(self,@CommandMinionAttack,#oMaster=self,#oTarget=what);

      % Face the target.
      Send(self,@MonsterOrient,#new_row=Send(what,@GetRow),
            #new_col=Send(what,@GetCol),#new_finerow=Send(what,@GetFineRow),
            #new_finecol=Send(what,@GetFineCol),#face_target=TRUE);

      % Do any special attack routines we might have.
      Send(self,@MonsterAttack,#what=what);

      propagate;
   }

   GetOffense(what = $, stroke_obj=$)
   "This returns the battler's ability to-hit.  Ranges from 1 to 2000."
   {
      local iAttack, i, iChilled, lRadiusState;

      if piOffense = $
      {
         iAttack = 4*piLevel + 8*piAim;
         
         if piLevel >= 150
         {
            iAttack = iAttack + viBaseSize/2;
         }
      }
      else
      {
         iAttack = piOffense;
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Dispassion)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
               #byClass=&Dispassion);
         iAttack = Send(Nth(lRadiusState,1),@ModifyHitRoll,#who=self,#what=what,
                        #hit_roll=iAttack,#lRadiusState=lRadiusState);
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Mirth)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
               #byClass=&Mirth);
         iAttack = Send(Nth(lRadiusState,1),@ModifyHitRoll,#who=self,#what=what,
                        #hit_roll=iAttack,#lRadiusState=lRadiusState);
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Melancholy)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
               #byClass=&Melancholy);
         iAttack = Send(Nth(lRadiusState,1),@ModifyHitRoll,#who=self,#what=what,
                        #hit_roll=iAttack,#lRadiusState=lRadiusState);
      }

      % Check for Chilled status effect, which lowers offense.
      iChilled = Send(self,@GetStatusEffect,#type=STATUS_CHILLED);
      if iChilled > 0
      {
         iAttack = iAttack - (iChilled * Send(SETTINGS_OBJECT,
                                                @GetElementalMultiple,
                                                #type=STATUS_CHILLED));
      }

      if piChampionStatus = CHAMPION_DEADLY
         OR piChampionStatus = CHAMPION_INDOMITABLE
      {
         iAttack = (iAttack * 4) / 3;
      }
      
      if piChampionStatus = CHAMPION_LEGENDARY
      {
         iAttack = (iAttack * 3) / 2;
      }

      if piEnch_flags & ENCH_PALSY
      {
         iAttack = iAttack * 3 / 4;
      }

      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
      {
         iAttack = Send(Nth(i,2),@ModifyHitRoll,
                                  #who=self,#what=what,#hit_roll=iAttack,
                                  #state=Nth(i,3));
      }

      return Bound(iAttack,1,$);
   }

   GetDefense(what = $, stroke_obj=$)
   "This returns the battler's ability to avoid being hit.  Ranges from "
   "1 to 2000."
   {
      local iDefense, iShocked, i;

      if piDefense = $
      {
         iDefense = 4*piLevel + 8*piAgility;
      }
      else
      {
         iDefense = piDefense;
      }

      % Check for Shocked status effect, which lowers defense.
      iShocked = Send(self,@GetStatusEffect,#type=STATUS_SHOCKED);
      if iShocked > 0
      {
         iDefense = iDefense - (iShocked * Send(SETTINGS_OBJECT,
                                                @GetElementalMultiple,
                                                #type=STATUS_SHOCKED));
      }

      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
      {
         iDefense = Send(Nth(i,2),@ModifyDefensePower,
                                 #who=self,#what=what,#defense_power=iDefense,
                                 #state=Nth(i,3));
      }

      if piChampionStatus = CHAMPION_TOUGH
         OR piChampionStatus = CHAMPION_INDOMITABLE
      {
         iDefense = (iDefense * 4) / 3;
      }
      
      if piChampionStatus = CHAMPION_LEGENDARY
      {
         iDefense = (iDefense * 3) / 2;
      }

      return Bound(iDefense,1,$);
   }

   % The next message deals with the three defense skills.  These messages
   %  return the relative values of the three skills.  Used for defense
   %  messages.

   GetDodgeAbility(stroke_obj=$)
   {
      if (stroke_obj <> $) AND NOT Send(stroke_obj,@CanDodge)
      {
         return 0;
      }

      return (viDifficulty * 10);
   }

   % This returns the damage done to target "what"
   GetDamage(what = $, stroke_obj=$)
   {
      local iDamage, iMultiplier, i, lRadiusState, iDamageBonus;

      iMultiplier = 1;

      if piMinDamage = $ and piMaxDamage = $
      {
         iDamage = Send(Self,@Fuzzy,#num=piLevel*100/Random(10,15));
      }
      else
      {
         if piMinDamage = $ OR piMinDamage > piMaxDamage
         {
            piMinDamage = piMaxDamage;
         }
         if piMaxDamage = $ OR piMaxDamage < piMinDamage
         {
            piMaxDamage = piMinDamage;
         }
         iDamage = random(piMinDamage*100,piMaxDamage*100);
      }

      iDamageBonus = 0;
      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Melancholy)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&Melancholy);
         iDamageBonus = Send(Nth(lRadiusState,1),@ModifyDamage,#who=self,
                              #what=what,#damage=iDamageBonus,#lRadiusState=lRadiusState);
      }
      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Mirth)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&Mirth);
         iDamageBonus = Send(Nth(lRadiusState,1),@ModifyDamage,#who=self,
                              #what=what,#damage=iDamageBonus,#lRadiusState=lRadiusState);
      }
      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Dispassion)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&Dispassion);
         iDamageBonus = Send(Nth(lRadiusState,1),@ModifyDamage,#who=self,
                              #what=what,#damage=iDamageBonus,#lRadiusState=lRadiusState);
      }
      if poMaster <> $
         AND IsClass(poMaster,&Player)
         AND Send(poMaster,@GetStance) <> $
         AND IsClass(Send(poMaster,@GetStance),&DefiantStandStance)
      {
         iDamageBonus = Send(Send(SYS,@FindSkillByNum,#num=SKID_DEFIANT_STAND_STANCE),@ModifyDamage,#who=poMaster,#iDamageBonus=iDamageBonus);
      }
      
      % Convert damage bonus to high precision.
      iDamage = iDamage + iDamageBonus*100;

      if piEnch_flags & ENCH_PALSY
      {
         iDamage = iDamage * 3 / 4 ;
      }

      if piChampionStatus = CHAMPION_DEADLY
         OR piChampionStatus = CHAMPION_INDOMITABLE
      {
         iMultiplier = 2;
      }
      
      if piChampionStatus = CHAMPION_LEGENDARY
      {
         iMultiplier = 3;
      }
      
      if poOwner <> $
         AND IsClass(poOwner,&ChaosStratumRoom)
         AND NOT (poMaster <> $ AND IsClass(poMaster,&Player))
      {
         iDamage = (iDamage * (100+Send(poOwner,@GetAddedMonsterDamage)))/100;
      }
      
      % Check for Charmed status.
      iDamage = iDamage - ((iDamage * Send(self,@GetStatusEffect,#type=STATUS_CHARMED))/Bound(Send(self,@GetHealth),1,$));

      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
      {
         iDamage = Send(Nth(i,2),@ModifyDamage,
                                 #who=self,#what=what,#damage=iDamage,
                                 #state=Nth(i,3));
      }

      return Bound(iDamage,0,$) * iMultiplier;
   }

   % This is the type of damage done.
   GetDamageType(what = $)
   {
      if pbIllusion
      {
         return 0;
      }
      return viAttack_type;
   }

   % This is the magical type of damage done.
   GetSpellType(what = $)
   {
      local i;
      
      if pbIllusion
      {
         return ATCK_SPELL_ILLUSION;
      }
      
      foreach i in plChampionAbilities
      {
         if First(i) = CHAMPION_ABIL_ELEMENTAL_DAMAGE_TYPE
         {
            return Nth(i,2);
         }
      }
      
      if poOwner <> $
         AND IsClass(poOwner,&ChaosStratumRoom)
         AND Send(poOwner,@GetMonsterElements) <> $
         AND NOT (poMaster <> $ AND IsClass(poMaster,&Player))
      {
         return Nth(Send(poOwner,@GetMonsterElements),Random(1,Length(Send(poOwner,@GetMonsterElements))));
      }

      return viAttack_spell;
   }
   
   GetBaseSpellType()
   {
      return viAttack_spell;
   }

   IsRangedAttack()
   {
      return FALSE;
   }

   % Handles damage done to monster
   % IMPORTANT NOTE: AssessDamage handles both legacy damage calculations and 
   % high precision damage calculation which avoid truncation. If you feed 
   % AssessDamage with a high precision damage number such as 941 for 9.41 
   % points of damage, you need to notify AssessDamage by passing it a 
   % #precision=TRUE. If you don't, AssessDamage will assume that you are 
   % passing a legacy damage value and multiply it by 100 for further 
   % calculations. Most notably, damage from attackspells and melee is now 
   % handled with high precision. Eventually, all damage calculations should 
   % be handled in high precision mode.
   AssessDamage(what=$,damage=0,atype=0,aspell=0,bonus=0,scalefactor=1000,
      absolute=FALSE,precision=FALSE,bDoingBackstab=FALSE,bSecondary=FALSE)
   {
      local iDamage, iResist, iPercentClass, i, each_obj,
            iCorrode, iCorrodeMultiple, iCorrodeReduction, iEmpowermentPercentage, oHighestDamager;
      
      if what <> $
         AND IsClass(what,&Player)
         AND Send(what,@HasSkill,#num=SKID_DESECRATION)
      {
         aspell = Send(Send(SYS,@FindSkillByNum,#num=SKID_DESECRATION),@ConvertDamageTypes,#who=what,#aspell=aspell);
      }

      % Check for stat steals
      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&DrainHex)
      {
         if what <> self
            AND IsClass(what,&Battler)
         {
            Send(Nth(i,2),@StealStat,#who=what,#what=self,#state=Nth(i,3));
         }
      }

      if NOT precision
      {
         damage = damage * 100;
      }

      if (piBehavior & AI_NPC)
      {
         Send(what,@MsgSendUser,#message_rsc=LS_nofight_attacked);

         return 0;
      }

      % Check for Damage to Mana from Spirit Shackles Hex.
      if what <> $
         AND (IsClass(what,&Player)
             OR IsClass(what,&Monster))
      {
         foreach i in Send(what,@GetEnchantmentsByClass,#enchClass=&Hex)
         {
            damage = Send(Nth(i,2),@AttackerDealsDamageToMana,#who=self,#what=what,#state=Nth(i,3),#damage=damage);
         }
      }
      if damage = 0
      {
         % Spirit Shackles took all the damage.
         return 0;
      }

      % Attacks against a minion master will cause minions to defend the master
      Send(self,@CommandMinionAttack,#oMaster=self,#oTarget=what);
      
      if poOwner <> $
      {
         foreach i in Send(poOwner,@GetObjectAttributes)
         {
            if IsClass(i,&RoomThreat)
            {
               damage = Send(i,@ThreatModifyDamage,#damage=damage,#atype=atype,#aspell=aspell);
            }
         }
      }

      if (IsClass(what,&Battler)
         OR IsClass(what,&AlchemyBomb))
         AND Send(SETTINGS_OBJECT,@GetEmpowermentsEnabled)
         AND NOT bSecondary
      {
         % Empowerments e.g. 6% increased acid damage
         iEmpowermentPercentage = 0;
         foreach i in Send(what,@GetCurrentEmpowerments)
         {
            if Nth(i,1) > 0
            {
               % Weapon empowerment.
               if atype & Nth(i,1)
               {
                  iEmpowermentPercentage = iEmpowermentPercentage + Nth(i,2);
               }
            }
            else
            {
               % Spell empowerment.
               if aspell & -Nth(i,1)
               {
                  iEmpowermentPercentage = iEmpowermentPercentage + Nth(i,2);
               }
            }
         }
         damage = (damage * (100+iEmpowermentPercentage))/100;
      }

      if IsClass(what,&Player)
         AND NOT bSecondary
      {
         if (aspell & ATCK_SPELL_HOLY
            OR aspell & ATCK_SPELL_UNHOLY)
            AND Send(what,@GetSkillAbility,#Skill_num=SKID_DEVOTION) > 0
         {
            bonus = Send(Send(SYS,@FindSkillByNum,#num=SKID_DEVOTION),
                                  @AddDamage,
                                  #who=what,
                                  #damage=bonus,
                                  #aspell=aspell);
         }
         if (aspell & ATCK_SPELL_COLD
            OR aspell & ATCK_SPELL_ACID)
            AND Send(what,@GetSkillAbility,#Skill_num=SKID_ENTROPY) > 0
         {
            bonus = Send(Send(SYS,@FindSkillByNum,#num=SKID_ENTROPY),
                                  @AddDamage,
                                  #who=what,
                                  #damage=bonus,
                                  #aspell=aspell);
         }
         if (aspell & ATCK_SPELL_FIRE
            OR aspell & ATCK_SPELL_SHOCK)
            AND Send(what,@GetSkillAbility,#Skill_num=SKID_ENERGY) > 0
         {
            bonus = Send(Send(SYS,@FindSkillByNum,#num=SKID_ENERGY),
                                  @AddDamage,
                                  #who=what,
                                  #damage=bonus,
                                  #aspell=aspell);
         }
         if (aspell & ATCK_SPELL_ILLUSION)
            AND Send(what,@GetSkillAbility,#Skill_num=SKID_HONESTY) > 0
         {
            % Players with Honesty do significantly less damage with illusions
            bonus = bonus - (Send(what,@GetSkillAbility,#Skill_num=SKID_HONESTY)*100)/9;
            Send(Send(SYS,@FindSkillByNum,#num=SKID_HONESTY),@DoSkill,#who=what);
         }
      }
      
      if NOT bSecondary
      {
         foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Bleed)
         {
            bonus = Send(Nth(i,2),@ModifyDamageTaken,#who=self,#bonus=bonus,#power=Nth(i,3));
         }
      }

      % check for any applicable resistances.

      if NOT absolute
         AND NOT bDoingBackstab
      {
         iDamage = Send(self,@ArmorCheck,#what=what,#bonus=bonus,#atype=atype,
            #aspell=aspell,#damage=damage);

         iCorrode = Send(self,@GetStatusEffect,#type=STATUS_CORRODE);
         if iCorrode > 0
         {
            iCorrodeMultiple = Send(SETTINGS_OBJECT,
                               @GetElementalMultiple,#type=STATUS_CORRODE);
         
            iCorrodeReduction = (iCorrode/iCorrodeMultiple);
            iDamage = bound(iDamage + iCorrodeReduction*100,1,damage);
         }

         iResist = Send(self,@ResistanceCheck,#atype=atype,#aspell=aspell,#what=what);
         iDamage = Send(self,@GetDamageFromResistance,#what=iDamage,#value=iResist);
         iDamage = iDamage + bonus;
         iDamage = iDamage * scalefactor / 1000;
      }
      else
      {
         iDamage = damage;
      }

      foreach i in plChampionAbilities
      {
         if First(i) = CHAMPION_ABIL_MAGIC_RESISTANCE
            AND aspell <> 0
         {
            iDamage = (iDamage * (100-Nth(i,2)) / 100);
         }
         if First(i) = CHAMPION_ABIL_WEAPON_RESISTANCE
            AND atype <> 0
         {
            iDamage = (iDamage * (100-Nth(i,2)) / 100);
         }
      }

      if IsClass(what,&Player)
         AND Send(what,@GetStance) <> $
         AND NOT bSecondary
      {
         iDamage = Send(Send(what,@GetStance),@LastPriorityModifyDamage,
                         #who=what,#what=self,#damage=iDamage);
      }

      % Set a predamage mark... we'll compare to it to see if threshold crossed.
      iPercentClass = piHit_points/(piMax_hit_points*20);

      % Make sure we don't deal negative damage.
      iDamage = Bound(iDamage,0,$);

      % Petrified monsters take no damage
      if Send(self,@IsEnchanted,#byClass=&Petrified)
      {
         iDamage = 0;
      }
      
      % I hate my target more if he hits me.
      if what = poTarget
      {
         % Should scale based on damage?
         piHatred = piHatred + 1;
      }
      else
      {
         % Our target is not the one that hit us
         if what <> $
            AND poTarget <> $
            AND IsClass(what,&Player)
            AND IsClass(poTarget,&Player)
            AND Send(what,@HasSkill,#num=SKID_BRAVERY)
            AND NOT Send(poTarget,@HasSkill,#num=SKID_BRAVERY)
         {
            Post(Send(SYS,@FindSkillByNum,#num=SKID_BRAVERY),@DoSkill,#who=what,#what=self);
         }
         else
         {
            oHighestDamager = Send(self,@GetHighestHurtMeRecentlyBattler);
            if poTarget <> $
               AND oHighestDamager <> $
               AND poTarget <> oHighestDamager
            {
               Post(self,@TargetSwitch,#what=oHighestDamager,#iHatred=Send(self,@GetHurtMeRecentlyAmount,#who=oHighestDamager));
               Post(self,@EnterStateChase,#target=oHighestDamager,#actnow=TRUE);
            }
         }
      }

      piHit_points = piHit_points - iDamage;
      
      if poOwner = $
      {
         return 0;
      }
      
      if piHit_points <= 0 
      {
         foreach i in Send(poOwner,@GetHolderActive)
         {
            each_obj = First(i);
            if IsClass(each_obj,&User)
               AND each_obj <> what
               AND Send(each_obj,@GetKillTarget)=self
            {
               Post(each_obj,@MsgSendUser,#what=self,
                    #message_rsc=vrParty_killed_monster,
                    #parm1=Send(what,@GetCapDef),#parm2=Send(what,@GetName),
                    #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));
            }
         }
         
         return $;
      }

      % Check to see if we crossed a threshold due to the damage.
      if iPercentClass <> (piHit_points / (piMax_hit_points * 20))
      {
         Send(self,@HitPointThresholdDamage);
      }

      % Let the attacker know if they hit some weakness/strength of the mob
      if IsClass(what,&player) AND NOT absolute
      {
         Post(what,@MsgPlayerHitResisted,#what=what,#resistance=iResist,
              #target=self,#color_rsc=monster_color_blue_rsc);
      }
      
      Send(self,@AddHurtMeRecently,#who=what,#amount=iDamage);

      % Apply possible elemental status effects
      if atype = 0
      {
         if aspell <> 0
         {
            Send(self,@ApplyElementalStatusEffects,#damage=damage/100,
                      #aspell=aspell,#what=what,#bSecondary=bSecondary);
         }
      }
      else
      {
         % Apply only half the effects from partially magical attacks
         if aspell <> 0
         {
            Send(self,@ApplyElementalStatusEffects,#damage=(damage/100/2),
                      #aspell=aspell,#what=what,#bSecondary=bSecondary);
         }
      }

      if NOT bSecondary
      {
         Send(self,@ApplyElementalImbalance,#aspell=aspell,#power=Send(what,@GetElementalImbalancePower,#aspell=aspell));
      }

      Post(self,@ReportHealthToAllies,#what=what,#damage=damage,#atype=atype,#aspell=aspell,#bonus=bonus,#scalefactor=scalefactor,
         #absolute=absolute,#precision=precision,#bDoingBackstab=bDoingBackstab,#bSecondary=bSecondary);

      return iDamage;
   }

   % Allows monsters to have armor not related to specific equipped items. 
   % Based on piArmor.
   ArmorCheck(what=$,damage=0,atype=0,aspell=0,bonus=0)
   {
      local iDamageReduce, oAttribute;

      foreach oAttribute in plObject_attributes
      {
         damage = Send(oAttribute,@ModifyDefenseDamage,#who=self,#what=what,
            #damage=damage,#atype=atype,#aspell=aspell);
      }

      iDamageReduce = 0;
      if piArmor <> 0
      {
         iDamageReduce = random(piArmor*33,piArmor*100);
         iDamageReduce = bound(iDamageReduce,0,(damage-100));
      }

      if aspell <> 0
      {
         % Reduce damage if part of the damage is spell
         if atype <> 0
         {
            % Only 2/3 of the damage reduction if we're doing both weapon
            % and spell damage types.
            iDamageReduce = iDamageReduce * 2 / 3;
         }
         else
         {
            % If we're doing pure spell damage, we get no reduction.
            iDamageReduce = 0;
         }
      }
      
      return damage - iDamageReduce;
   }

   AssessHit(what = $, stroke_obj = $, damage = $, use_weapon=$)
   "This does the fallout of a hit, gives appropriate message, etc.  "
   "Called on self when hit opponent."
   {
      if poOwner = $
      {
         % No owner to send this to, so propagate.
         propagate;
      }

      % If use_weapon isn't $, usually because we're casting a spell or doing some other form of damage
      if use_weapon = $
         AND vrSound_miss <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=vrSound_miss,
               #flags=SOUND_RANDOM_PITCH);
         if (IsClass(what,&Player))
         {
            Send(poOwner,@SomethingWaveRoom,#what=what,
                  #wave_rsc=Send(what,@GetOuchSound),#flags=SOUND_RANDOM_PITCH);
         }
      }

      propagate;
   }

   AssessMiss(what = $, stroke_obj = $)
   "This does the fallout of a miss, gives appropriate message, etc.  "
   "Called on target when missing."
   {
      if poOwner = $
      {
         % No owner to send this to, so propagate.
         propagate;
      }

      if vrSound_miss <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=vrSound_miss,
               #flags=SOUND_RANDOM_PITCH);
      }

      propagate;
   }

   % This function handles damage done, etc.
   DidDamage(what = $, amount = 0)
   {
      Send(self,@HitSideEffect,#what=what);
      Send(self,@DoCrit,#what=what);
      
      if poMaster <> $
         AND IsClass(poMaster,&Player)
      {
         Send(poMaster,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=TRUE);
      }

      return;
   }

   % Can an opponent dodge this monster's attack?
   CanDodge()
   {
      return TRUE;
   }

   % Can an opponent parry this monster's attack?
   CanParry()
   {
      return TRUE;
   }

   % Can an opponent block this monster's attack with a shield?
   CanBlock()
   {
      return TRUE;
   }

   % This function returns the name of the monster's attack.
   GetAttackName()
   {
      return monster_default_attack;
   }

   GetVisionDistance()
   "Returns vision radius."
   {
      return piVisionDistance;
   }

   GetAttackRange()
   "Returns the attack range of the monster, in FINENESS units. "
   "Default for most monsters is 128 (2 row/col units)."
   {
      return piAttackRange;
   }

   GetOptimalRange()
   "For most monsters, this is the attack range."
   {
      return piAttackRange;
   }

   CanSee(what = $)
   {
      if what = $
      {
         return FALSE;
      }

      if poOwner <> Send(what,@GetOwner)
      {
         return FALSE;
      }

      if (Send(self,@SqFineDistToVision,#what=what) / FINENESS_SQUARED)
               <= (piVisionDistance*piVisionDistance)
      {
         return TRUE;
      }

      return FALSE;
   }

   ValidAttack(who=$)
   {
      local iRange;

      iRange = Send(self,@GetAttackRange);

      if who = poTarget
      {
         % Range in FINENESS units.
         if Send(self,@SquaredFineDistanceTo3D,#what=who)
               > (iRange * iRange)
         {
            return;
         }

         piState = (piState & VSTATE_VALIDITY_MASK);
         piState = (piState | VSTATE_VALID_ATTACK);
      }

      return;
   }

   CanReach( what = $ )
   {
      local iRange;
      
      iRange = Send(self,@GetAttackRange);

      if poOwner <> Send(what,@GetOwner)
      {
         return FALSE;
      }

      % Check range first, for speed (in FINENESS units).
      if Send(self,@SquaredFineDistanceTo3D,#what=what)
            > (iRange * iRange)
      {
         if what = poTarget
         {
            piState = (piState | VSTATE_INVALID_ATTACK);
         }

         return FALSE;
      }

      % if neither the player or the monster has moved lately,
      % we don't have to check this stuff again.
      if what = poTarget
      {
         if (piState & VSTATE_VALID_ATTACK)
         {
            return TRUE;
         }

         if (piState & VSTATE_INVALID_ATTACK)
         {
            return FALSE;
         }
      }

      % Some monsters (revenants) don't care about walls.
      if (piBehavior & AI_FIGHT_THROUGH_WALLS)
      {
         if what = poTarget
         {
            piState = (piState | VSTATE_VALID_ATTACK);
         }

         return TRUE;
      }

      %% Okay, now then, check for walls.
      if Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
      {
         if what = poTarget
         {
            piState = (piState | VSTATE_VALID_ATTACK);
         }

         return TRUE;
      }
      if what = poTarget
      {
         piState = (piState | VSTATE_INVALID_ATTACK);
      }

      return FALSE;
   }

   CanReachLocation(row=$,col=$,fine_row=$,fine_col=$)
   {
      local iRange;

      iRange = Send(self,@GetAttackRange);

      if Send(self,@SquaredFineDistanceToLocation3D,#row=row,#col=col,
            #fine_row=fine_row,#fine_col=fine_col)
         <= (iRange * iRange)
      {
         return TRUE;
      }

      return FALSE;
   }

   %%% Movement messages

   MoveTowards(oTarget = $, face_target=FALSE, face_away=FALSE,
               to_master=FALSE)
   {
      if oTarget = $ 
      { 
         Debug("Bad info passed to MoveTowards!");
         return FALSE; 
      }

      return Send(self, @MoveTowardsCoords,
                   #iRow=Send(oTarget,@GetRow),
                   #iCol=Send(oTarget,@GetCol),
                   #iFineRow=Send(oTarget,@GetFineRow),
                   #iFineCol=Send(oTarget,@GetFineCol),
                   #face_target=face_target,
                   #face_away=face_away,
                   #to_master=to_master);
   }

   MoveAway(oTarget = $, face_target=FALSE, face_away=FALSE)
   {
      local drow,dcol;
  
      if oTarget = $
      {
         Debug("Bad info passed to MoveAway!");
         return FALSE;
      }

      if poOwner <> Send(oTarget,@GetOwner)
      {
         return FALSE;
      }

      % calculate square delta in fineness
      % vector from oTarget to self
      drow = (piRow * FINENESS) + piFine_row;
      dcol = (piCol * FINENESS) + piFine_col;
      drow = drow - ((Send(oTarget,@GetRow) * FINENESS) + Send(oTarget,@GetFineRow));
      dcol = dcol - ((Send(oTarget,@GetCol) * FINENESS) + Send(oTarget,@GetFineCol));

      % add vector from oTarget to self on our position and try move there
      return Send(self, @MoveTowardsCoords,
                   #iRow=(piRow + (drow / FINENESS)),
                   #iCol=(piCol + (dcol / FINENESS)),
                   #iFineRow=(piFine_row + (drow MOD FINENESS)),
                   #iFineCol=(piFine_col + (dcol MOD FINENESS)),
                   #face_target=face_target,
                   #face_away=face_away);
   }

   ReqMonsterMove(new_row = $,new_col = $,new_finerow = FINENESS_HALF,
                  new_finecol = FINENESS_HALF)
   "Called by monster moving code to check if we really want to go"
   "to <new_row>,<new_col>."
   {
      local r,c;

      if NOT (piBehavior & AI_MOVE_WALKTHROUGH_WALLS)
      {
         return TRUE;
      }

      % Get coordinates in highres squares
      r = ((new_row * FINENESS) + new_finerow) / 16;
      c = ((new_col * FINENESS) + new_finecol) / 16;

      % Monsters that can attack/move through walls shouldn't wander off the
      %  map.
      if r > Send(poOwner,@GetRoomRowsHighRes)
         OR r < 1
         OR c > Send(poOwner,@GetRoomColsHighRes)
         OR c < 1
      {
         return FALSE;
      }

      return TRUE;
   }
    
   MonsterOrient(new_row = $,new_col = $,new_finerow = FINENESS_HALF,
               new_finecol=FINENESS_HALF,face_target = FALSE, face_away=FALSE)
   "Called by monster moving code before and after a real move"
   {
      local drow, dcol, iAngle;

      % aiming towards a target or away from it
      if (NOT (poTarget = $)) AND (face_target OR face_away)
      {
         % build face towards (in fine-units)
         drow = (Send(poTarget,@GetRow) * FINENESS) + Send(poTarget,@GetFineRow);
         dcol = (Send(poTarget,@GetCol) * FINENESS) + Send(poTarget,@GetFineCol);
         drow = drow - ((piRow * FINENESS) + piFine_row);
         dcol = dcol - ((piCol * FINENESS) + piFine_col);

         % rotate 180??, if we face away
         if face_away
         {
            drow = -drow;
            dcol = -dcol;
         }
      }
      else
      {
         drow = (new_row * FINENESS) + new_finerow;
         dcol = (new_col * FINENESS) + new_finecol;
         drow = drow - ((piRow * FINENESS) + piFine_row);
         dcol = dcol - ((piCol * FINENESS) + piFine_col);
      }

      if poOwner <> $
      {
         iAngle = Send(SYS,@UtilGetAngleTowards,#row=drow,#col=dcol);
         Send(poOwner,@SomethingTurned,#what=self,#new_angle=iAngle);
      }

      return;
   }

   MoveTowardsCoords(iRow=$, iCol=$, iFineRow=FINENESS_HALF, iFineCol=FINENESS_HALF,
                     face_target=FALSE, face_away=FALSE, to_master=FALSE)
   {
      local iState, iMoveFlags;

      if (iRow = $ or iCol = $)
      {
         return;
      }

      % Mobs that can move outside the BSP tree set this field which is then
      % combined with the state flags and sent to GetStepTowardsBSP. These
      % moves aren't checked against room geometry.
      iMoveFlags = 0;
      if (piBehavior & AI_MOVE_WALKTHROUGH_WALLS)
      {
         iMoveFlags = iMoveFlags | MSTATE_MOVE_OUTSIDE_BSP;
      }

      % query where to step next
      % note: these need some persistent info across
      % calls which are stored in piState (flags from old KOD code)
      iState = GetStepTowardsBSP(
                Send(poOwner, @GetRoomData),
                piRow, piCol, piFine_row, piFine_col,
                *iRow, *iCol, *iFineRow, *iFineCol,
                piState | iMoveFlags, self);

      if iState <> $
      {
         piState = iState;

         % debug("step",iRow,iCol,iFineRow,iFineCol);
	  
         if (NOT (piBehavior & AI_MOVE_WALKTHROUGH_WALLS))
             OR Send(self,@ReqMonsterMove,#new_row=iRow,#new_col=iCol,
                     #new_finerow=iFineRow,#new_finecol=iFineCol)
         {
            Send(self,@MonsterOrient,#new_row=iRow,#new_col=iCol,
                 #new_finerow=iFineRow,#new_finecol=iFineCol,
                 #face_target=face_target,#face_away=face_away);
		
            Send(poOwner,@SomethingMoved,#what=self,#speed=piMoveSpeed,
                 #new_row=iRow,#new_col=iCol,
                 #fine_row=iFineRow,#fine_col=iFineCol,
                 #non_monsters_only=TRUE);

            % Turn to face target
            Send(self,@MonsterOrient,#new_row=iRow,#new_col=iCol,
                 #new_finerow=iFineRow,#new_finecol=iFineCol,
                 #face_target=face_target,#face_away=face_away);

         return TRUE;		
         }
      }

      return FALSE;
   }

   GotoCoords(iRow=$,iCol=$,iFineRow=FINENESS_HALF,iFineCol=FINENESS_HALF)
   "Move to a specific row and column. warning! fineness really"
   "isn't accurate as the monster will stop when it reaches the destination"
   "row and column"
   {
      if (iRow = $ OR iCol = $)
      {
         return;
      }

      piTargetLocationRow = iRow;
      piTargetLocationCol = iCol;
      piTargetLocationFineRow = iFineRow;
      piTargetLocationFineCol = iFineCol;
      Send(self,@SetBehaviorFlag,#flag=AI_HAS_TARGET_LOCATION,#value=TRUE);

      return;
   }

   GetTargetLocationRow()
   {
      return piTargetLocationRow;
   }

   GetTargetLocationCol()
   {
      return piTargetLocationCol;
   }

   GetTargetLocationFineRow()
   {
      return piTargetLocationFineRow;
   }

   GetTargetLocationFineCol()
   {
      return piTargetLocationFineCol;
   }

   %%% Spasming messages

   SpasmMonsterTimer()
   {
      if poOwner = $ OR NOT (viAttributes & MOB_SPASM)
      {
         return;
      }

      ptSpasm = $;
      Send(self,@DoSpasm);
      ptSpasm = CreateTimer(self,@SpasmMonsterTimer,
                            viSpasm_delay+Random(0,viSpasm_delay/3));

      return;
   }

   DoSpasm()
   {
      return;
   }

   %%% Receive messages

   CanAcceptGift()
   {
      % We AND this with TRUE so that we get a boolean instead of the raw
      %  value.
      return ((viAttributes & MOB_RECEIVE) AND TRUE);
   }

   CanAcceptOffer(who=$)
   {
      return ((viAttributes & MOB_BUYER OR viAttributes & MOB_RECEIVE)
               OR (who <> $ AND IsClass(who,&DM)));
   }

   ReqOffer(what = $, item_list = $)
   "Someone offered us something, figure out if we want it, etc. "
   "Return TRUE if the offer should go through, meaning that the monster will "
   "offer the value of the items in return."
   {
      local i,j, lArgList, iValueOffered, oQuestNode, bIsBuyer, bWarnAboutUnwantedItems;

      if item_list = $
      {
         return FALSE;
      }

      % Check for if in the same room.
      if Send(what,@GetOwner) <> poOwner
      {
         Debug("ALERT! ",Send(what,@GetTrueName),what,"offered items to NPC",
               Send(self,@GetTrueName),"from distant RID",
               Send(Send(what,@GetOwner),@GetRoomNum));
         
         return FALSE;
      }     

      % If there are active quest nodes, notify them   -AJM
      foreach i in item_list
      {
         %% first, let's be sure the item CAN be given away.
         if NOT Send(i,@CanBeGivenToNPC)
         {
            Post(self,@SayToOne,#target=what,#message_rsc=LS_cant_part,
                 #parm1=Send(i,@GetIndef),#parm2=Send(i,@GetName));

            return FALSE;
         }

         if NOT Send(what,@ReqLeaveHold,#what=i)
         {
            Post(what,@MsgSendUser,#message_rsc=Lm_cant_remove_item,
                 #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));

            return FALSE;
         }

         if plActiveQuestNodes <> $
         {
            foreach oQuestNode in plActiveQuestNodes
            {
               if Send(oQuestNode,@CheckCompletionCriteria,#who_tried=what,
                       #item_offered=i)
               {
                  return FALSE;
               }
            }
         }
      } 

      bIsBuyer = Send(self, @MobIsBuyer);
      if (viAttributes & MOB_RECEIVE)
      {
         % If we also buy items, don't complain about being offered something
         % that we can't use for a quest.  Maybe we'll buy it.
         bWarnAboutUnwantedItems = (NOT Send(self, @MobIsVaultman)) AND
              (NOT bIsBuyer);
         if Send(self,@ReqGive,#what=what,#item_list=item_list,
                 #notify_about_unwanted_items = bWarnAboutUnwantedItems)
         {
            return FALSE;
         }
         
         % If we both buy items and receive them, fall through to the buy case.
         if NOT bIsBuyer
         {
            return FALSE;
         }
      }

      if bIsBuyer
      {
         if poCustomer <> $
         {
            Send(what,@MsgSendUser,#message_rsc=Lm_buyer_offer_busy,
                 #parm1=Send(self,@GetName));

            return FALSE;
         }

         iValueOffered = 0;

         foreach i in item_list
         {
            if NOT Send(what,@ReqLeaveHold,#what=i)
            {
               Post(what,@MsgSendUser,#message_rsc=Lm_cant_remove_item,
                    #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));

               return FALSE;
            }

            if NOT Send(self,@ObjectDesired,#what=i)
            {
               Send(self,@SayToOne,#target=what,
                    #message_rsc=Lm_buyer_unwanted);

               return FALSE;
            }

            iValueOffered = iValueOffered + Send(i,@GetValue);
         }

         if iValueOffered = 0
         {
            Send(self,@SayToOne,#target=what,#message_rsc=Lm_buyer_no_value);

            return FALSE;
         }

         if NOT Send(self,@IsCustomerOkay,#who=what)
         {
            return FALSE;
         }

         return TRUE;
      }

      % Let DMs give monsters stuff - will drop on death.
      if IsClass(what,&DM)
      {
         return TRUE;
      }

      return FALSE;
   }

   ReqGive(what = $, item_list = $, notify_about_unwanted_items = True)
   "Returns TRUE if we'll take everything that was offered."
   {
      local i, j, bWanted, oQuestNode, bAllWanted;

      bAllWanted = TRUE;

      foreach i in item_list
      {
         if NOT Send(what,@ReqLeaveHold,#what=i)
         {
            Post(what,@MsgSendUser,#message_rsc=LM_cant_remove_item,
                 #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));

            return FALSE;
         }

         % If there are active quest nodes, notify them   -AJM
         if plActiveQuestNodes <> $
         {
            foreach oQuestNode in plActiveQuestNodes
            {
               if Send(oQuestNode,@CheckCompletionCriteria,#who_tried=what,
                       #item_offered=i)
               {
                  return TRUE;
               }
            }
         } 

         bWanted = FALSE;
         bAllWanted = FALSE;
         foreach j in plWantedItems 
         {
            if IsClass(i,j)
            {
               % We were offered something we want.
               Send(Self,@GotWantedItem,#obj=i,#who=what);
               bWanted = TRUE;

               break;
            }
         }

         % Were we offered something we dont want?
         if (NOT bWanted) AND notify_about_unwanted_items
         {
            Send(Self,@GotUnwantedItem,#obj=i,#who=what);
         }
      }
      
      % Last chance.  Am I a vaultman?
      if Send(self,@MobIsVaultman)
      {            
         Send(self,@VaultDeposit,#who=what,#lItems=item_list);
         return TRUE;
      }

      return bAllWanted;
   }
   
   GotWantedItem(obj = $, who = $)
   "We have been given an item on our wanted list. This is either a banker"
   "type, or a quest completion of some kind or an intrigue token."
   {
      local iQuestID,oLibrary,iQuestType;

      % Handle the kludgy banker interface immediately.
      if (viAttributes & MOB_BANKER) AND IsClass(obj,&Money)
      {
         Send(self,@BankDeposit,#who=who,#amount=Send(obj,@GetNumber));

         return;
      }

      oLibrary = Send(SYS,@GetLibrary);
      iQuestID = Send(oLibrary,@GetQuestID,#who=self);
      iQuestType = Send(oLibrary,@GetQuestType,#id=iQuestID);

      % If were involved in an object quest, lets see if this was the right
      %  one.
      if iQuestID > 0
         AND (iQuestType=QST_PERM_OBJECT OR iQuestType=QST_TEMP_OBJECT)
         AND IsClass(obj,GetClass(Send(oLibrary,@GetQuestGoal,#id=iQuestID)))
      {
         if NOT Send(oLibrary,@FinishedQuest,#who=who,#id=iQuestID)
         {
            return;
         }
      }
      else
      {
         % We musta wanted the item for some other reason. So do special stuff
         % If we get a FALSE return, it means we didnt keep the item.
         if NOT Send(self,@CheckWhyWanted,#obj=obj,#who=who)
         {
            return;
         }

         % accepting some items makes NPC's happier or sadder
         Send(self,@AffectMood,#why=MOODMOD_ACCEPT_ITEM,#what=obj);

         if isClass(obj,&Token) AND Send(SYS,@GetTokenGame) <> $
         {
            Send(Send(SYS,@GetTokenGame),@TokenDelivered,
                 #what=obj,#who=who,#mob=self);

            return;
         }
      }

      %Lets dispose of the offered item.
      if IsClass(obj,&NumberItem) 
      {
         Send(who,@RemoveNumberItemFromPossession,#ToBeRemoved=obj);
      }

      Send(obj,@Delete);

      return;
   }

   GotUnwantedItem(obj = $, who = $)
   "Someone just randomly gave us an object we didnt really want."
   "They could be fishing for a quest, so occasionally, lets keep it."
   {
      local iRnd,oMoney,i,lReward,oLibrary,iQuestID;
 
      % Quickly, lets check to see if it's a signet ring.  If so, give a
      %  special message.
      If IsClass(obj,&SignetRing)
      {
         Post(poOwner,@SomeoneSaid,#what=self,
              #string=LS_Signet_wrong,#type=SAY_RESOURCE,
              #parm1=Send(Send(obj,@GetRingOwner),@GetDef),
              #parm2=Send(Send(obj,@GetRingOwner),@GetName));

         return;
      }

      oLibrary=Send(sys,@Getlibrary);
      iQuestID=Send(oLibrary,@GetQuestID,#who=self);
      lReward=Send(oLibrary,@GetQuestReward,#id=iQuestID);

      % If were a permquester then maybe the person has already done it.
      if iQuestID > 0
         AND First(lReward) = QST_REWARD_ID 
         AND Send(oLibrary,@HasDoneQuestID,#who=who,#questID=Nth(lReward,2))
      {
         Post(self,@SayToOne,#target=who,
              #message_rsc=LS_already_done_permquest);

         return;
      }

      % Perhaps the item was meant for an earlier quest,but is now too late.
      % If so, lets return the item to the player.

      foreach i in Send(oLibrary,@GetOldClasses,#mob=self)
      {
         if IsClass(obj,i)
         {
            Post(self,@SayToOne,#target=who,#message_rsc=LS_unwanted_oldquest);
            if IsClass(obj,&NumberItem)
            {
               Send(obj,@Delete);
            }
            else
            {
               Send(who,@NewHold,#what=obj);
            }

            return;
         }
      }

      % Handle giving us a token.  In general, we don't want it.
      if isClass(obj,&Token) AND NOT isClass(self,&DragonFlyQueen)
      {
         Post(who,@MsgSendUser,#message_rsc=vrUnwanted_token,
              #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
         Send(obj,@OfferRejected);
         Send(who,@NewHold,#what=obj);

         return;
      }

      % So this really was a random offering it appears so lets act alive.
      % We say no thanks, and return the item to the giver.
      Post(who,@MsgSendUser,#message_rsc=vrUnwanted_give,
           #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
      if IsClass(obj,&NumberItem)
      {
         % Delete the numberitem because it was created special for the offer.
         % Giver still has all the original number.
         Send(obj,@Delete);
      }
      else
      {
         Send(who,@NewHold,#what=obj);
      }

      return;
   }

   %%% Speech messages

   SomeoneSaid(what = $,type = $,string = $)
   "Takes the said string and if its from a user searches libraries for"
   "a response."
   {
      local i,lActionList, oLibrary,iQuestID,iQuestType, oQuestNode;

      % Are we supposed to hear things?
      if (NOT (viAttributes & MOB_LISTEN))
         OR string = $
      {
         propagate;
      }

      % Was it a user talking, another NPC, or myself?
      if NOT IsClass(what,&User)
      {
         if what = self OR NOT (viAttributes & MOB_LISTEN_MOB)
         {
            propagate;
         }
      }
      
      if IsClass(what,&Player)
      {
         % Let the user's passive quests know he/she said something to this npc.
         Send(what,@PassiveQuestUserSaidToMe,#what=self,#type=type,#string=string);
      }

      oLibrary = Send(SYS,@GetLibrary);

      % Anonymous (and morph) filter
      % Don't handle triggers normally if player's anonymous flag is set,
      % just say anonymous_response

      if IsClass(what,&Player)
         AND (Send(what,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
              OR Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED))
         AND type <> SAY_DM
         AND vbIgnoresAnonAndMorph
      {
         Send(what,@MsgSendUser,#message_rsc=monster_anonymous_response,
              #parm1=Send(self,@GetName));

         return;
      }

      % Quest engine hook: if there are active quest nodes, notify them   -AJM
      if plActiveQuestNodes <> $
      {
         foreach oQuestNode in plActiveQuestNodes
         {
            if Send(oQuestNode,@CheckCompletionCriteria,#who_tried=what,
                    #message=string)
            {
               return;
            }
         }
      }

      %% Old quest stuff (and old old quest stuff)
      iQuestID = Send(oLibrary,@GetQuestID,#who=self);

      % If were on a quest, then scan the libraries to see if we have
      %  a match, and if so then finish the quest.
      if iQuestID > 0
      {
         iQuestType = Send(oLibrary,@GetQuestType,#id=iQuestID);

         if (iQuestType=QST_PERM_PHRASE OR iQuestType=QST_TEMP_PHRASE)
            AND Send(oLibrary,@IsQuestStringMatch,#string=string,#id=iQuestID,
                     #who=what,#mob=self)
         {
            Send(oLibrary,@FinishedQuest,#who=what,#id=iQuestID);

            propagate;
         }
      }

      % If it wasnt a current quest, maybe it was an old quest.
      foreach i in Send(oLibrary,@GetOldPhrases,#mob=self)
      {
         if Send(oLibrary,@IsQuestStringMatch,
                 #string=string,#goal=i,#who=what,#mob=self)
         {
            propagate;
         }
      }

      % Maybe it was just a simple speech trigger. So, we check and parse.
      lActionList = $;
      lActionList = Send(oLibrary,@SearchSpeechLib,#mob=self,#string=string);
      if lActionList <> $
      {
         Post(oLibrary,@ParseAction,#action=First(lActionList),
              #mob=self,#target=what);
         Send(self,@AddToSpamList,#mob_class=Nth(lActionList,2),
              #key_num=Nth(lActionList,3));            
      }
      
      % Last but not least, is the player asking about one of my spells/skills?
      if (viAttributes & MOB_TEACHER) 
      {
         Send(self,@SomeoneSaidLevel,#what=what,#string=string);
      }

      % The investigator can use "dm top accounts" or "dm PlayerName" to get
      %  info on accounts.
      if type = SAY_DM
         AND Send(self,@MobIsBanker)
         AND (Send(SYS,@GetInvestigator) = what)
      {
         if stringEqual(string,"top accounts")
         {
            Send(self,@ReportBankBalance,#number=10);

            propagate;
         }

         i = Send(SYS,@FindUserByString,#string=string);
         if i <> $
         {
            Send(self,@ReportBankBalance,#who=i);

            propagate;
         }
      }

      propagate;
   }

   SomeoneSaidLevel(what = $,type = $,string = $)
   {
      local iLevel;

      if (Nth(plFor_Sale,2) = $ AND Nth(plFor_Sale,3) = $)
         OR NOT StringContain(string,monster_level)
      {
         return FALSE;
      }

      if StringContain(string,monster_one)
         OR StringContain(string,monster_num_one)
      {
         iLevel = 1;
      }
      else if StringContain(string,monster_two)
            OR StringContain(string,monster_num_two)
      {
         iLevel = 2;
      }
      else if StringContain(string,monster_three)
               OR StringContain(string,monster_num_three)
      {
         iLevel = 3;
      }
      else if StringContain(string,monster_four)
               OR StringContain(string,monster_num_four)
      {
         iLevel = 4;
      }
      else if StringContain(string,monster_five)
               OR StringContain(string,monster_num_five)
      {
         iLevel = 5;
      }
      else if StringContain(string,monster_six)
               OR StringContain(string,monster_num_six)
      {
         iLevel = 6;
      }

      if iLevel = $
      {
         return FALSE;
      }

      Post(self,@ReportLevel,#iLevel=iLevel);

      return TRUE;
   }

   ReportLevel(iLevel=0)
   {
      local i, oAbility, iNum, lAvailable;

      lAvailable = $;

      iNum = 0;
      foreach i in nth(plFor_Sale,2)
      {         
         oAbility = Send(SYS,@FindSkillByNum,#num=i);
         if iLevel = Send(oAbility,@GetLevel)
            AND Send(oAbility,@IsAccessible)
         {
            if oAbility <> $
            {
               lAvailable = Cons(oAbility,lAvailable);
            }
         }
      }

      foreach i in nth(plFor_Sale,3)
      {         
         oAbility = Send(SYS,@FindSpellByNum,#num=i);
         if iLevel = Send(oAbility,@GetLevel)
            AND Send(oAbility,@IsAccessible)
         {
            if oAbility <> $
            {
               lAvailable = Cons(oAbility,lAvailable);
            }
         }
      }

      if poOwner = $
      {
         return;
      }

      Send(self,@SendReportLevel,#lAvailable=lAvailable);

      return;
   }

   SendReportLevel(lAvailable=$)
   {
      local i, iNumAbilities, iNumRsc, iCounter;

      AddPacket(1,BP_SAID, 4,self, 4,Send(self,@GetName), 1,SAY_RESOURCE,
                4,monster_said_resource_str, 4,Send(self,@GetCapDef),
                4,Send(self,@GetName));

      if lAvailable = $
      {
         AddPacket(4, vrTeach_nothing);
         Send(poOwner,@SendCopyPacketAllInRoom);

         return;
      }

      % Add master rsc.
      AddPacket(4,vrTeach_message);

      iCounter = 0;
      iNumRsc = 0;

      iNumAbilities = Length(lAvailable);

      foreach i in lAvailable
      {
         iCounter++;

         if iNumAbilities > 1
         {
            if iCounter = iNumAbilities
            {
               iNumRsc = iNumRsc + 2;
               if IsClass(self,&KocatanBonePriestess)
               {
                  AddPacket(4,Send(self,@GetRandomSquawkRsc),4,Send(i,@GetName));
               }
               else
               {
                  AddPacket(4,monster_teach_and, 4,Send(i,@GetName));
               }
            }
            else
            {
               iNumRsc = iNumRsc + 2;
               AddPacket(4,Send(i,@GetName), 4,monster_teach_comma);
            }
         }
         else
         {
            iNumRsc++;
            AddPacket(4,Send(i,@GetName));
         }
      }

      % If we didn't add enough location resources, make up for it
      % with blank ones.
      while iNumRsc++ < 12
      {
         AddPacket(4,monster_teach_blank);
      }

      Send(poOwner,@SendCopyPacketAllInRoom);

      return;
   }

   GetTeachMessage(level=$)
   {
      return vrTeach_message;
   }

   OnSpamList(mob_class = $, key_num = 0)
   "Return TRUE if speech item is on the spam list."
   {
      local lSpeechItem;

      if plSpamList = $
      {
         return FALSE;
      }

      if key_num = 0 OR mob_class = $
      {
         return FALSE;
      }

      % plSpamlist is [ [mob_class, key_num],...]
      % List should be small, so we'll just do a linear search.
      foreach lSpeechItem in plSpamList
      {
         if First(lSpeechItem) = mob_class AND Nth(lSpeechItem,2) = key_num
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   AddToSpamList(mob_class = $, key_num = 0)
   "Add a speech item to the spam list."
   {
      if key_num = 0 OR mob_class = $
      {
         return;
      }

      % plSpamlist is [ [mob_class, key_num],...]
      plSpamList = Cons([mob_class,key_num], plSpamList);

      % Spam list cleared with random timer, so if we add something we need
      % to make sure that timer is set.
      if (ptRandom = $)
      {
         ptRandom = CreateTimer(self,@RandomTimer,viRandom_delay
                        + Random(0,viRandom_delay/2));
      }

      return;
   }

   %%% Random Messages

   RandomTimer(test = FALSE)
   "Handle a random timer, and set up the next one."
   {
      local lAction, iNum, oTarget, i, lActives, oLibrary;

      ptRandom = $;

      % Clear spam list
      plSpamList = $;

      if poOwner = $ OR NOT ((viAttributes & MOB_RANDOM) OR test)
      {
         return;
      }

      % This has to stay >0 or things go bad in library.
      iNum = Random(1,100);   

      oLibrary = Send(SYS,@GetLibrary);
      lAction = Send(oLibrary,@SearchRandomLib,#mob=self,#percent=iNum);
      if lAction <> $
      {
         % we found an applicable random trigger, find a random user.
         iNum = 0;
         oTarget = $;
         foreach i in Send(poOwner,@GetHolderActive)
         {
            if IsClass(First(i),&User)
            {
               if Random(0,iNum) = 0
               {
                  oTarget = First(i);
               }

               iNum = iNum + 1;
            }
         }

         if oTarget = $
         {
            Debug("BAD: RandomTimer Expired without user present");

            return;
         }

         Send(oLibrary,@ParseAction,#action=lAction,#mob=self,#target=oTarget);
      }
      
      if NOT test
      {
         ptRandom=CreateTimer(self,@RandomTimer,
                              viRandom_delay + Random(0,viRandom_delay/2));
      }

      return;
   }

   %%% Other Trigger messages

   AmbientLightChanged(test = FALSE)
   "Triggered every Meridian hour (5 min).  Used to damp out mood swings and "
   "trigger time-of-day mood changes."
   {
      local iHour, iMoodMod;
      iHour = Send(SYS,@GetHour);

      if iHour = 6
      {
         Send(self,@AffectMood,#why=MOODMOD_DAWN);
         piSweepCounter = 0;
      }

      if iHour = 18
      {
         Send(self,@AffectMood,#why=MOODMOD_DUSK);
      }

      % Damp out mood swings every 4 Meridian hours
      if (iHour mod 4 = 0) OR test
      {
         % if in [-5, 5] do nothing
         if piMood >= -5 AND piMood <= 5
         {
            return;
         }

         % otherwise move halfway to [-5, 5]
         iMoodMod = ((abs(piMood) - 5) / 2) * (piMood / abs(piMood));
         Send(self,@SetMood,#new_mood=piMood-iMoodMod);
      }

      propagate;
   }

   UserEntered(who = $)
   "A User just entered the room."
   {
      return;
   }

   MonsterAttack(what = $)
   "Called by monster attacking code right before taking a swing at <what>."
   {
      return;
   }

   HitSideEffect(what=$)
   "Called after every non-fatal monster hit"
   {
      local i, oPurge, oDisarm;

      foreach i in plChampionAbilities
      {
         if First(i) = CHAMPION_ABIL_PURGE
         {
            if Random(1,100) < Nth(i,2)
            {
               oPurge = Send(SYS,@FindSpellByNum,#num=SID_PURGE);
               if oPurge <> $
                  AND Send(what,@IsEnchanted)
               {
                  if IsClass(what,&Player)
                  {
                     Send(what,@MsgSendUser,#message_rsc=champion_purge_msg);
                  }
                  % Chances equal to a purge weapon
                  Send(oPurge,@DoPurge,#who=what,#iSpellPower=Random(25,75),#caster=self);
               }
            }
         }
         
         if First(i) = CHAMPION_ABIL_DISARM
         {
            if Random(1,100) < Nth(i,2)
            {
               oDisarm = Send(SYS,@FindSkillByNum,#num=SKID_DISARM);
               Send(oDisarm,@DoSkill,#who=self,#oTarget=what);
            }
         }
      }

      return;
   }

   DoCrit(what=$)
   {
      if Random(1,10000) <= viCriticalHitRate
      {
         if vbCanCauseStun
         {
            Send(what,@ApplyStun,#what=self,#stun_power=Send(self,@GetSize));
         }
         if vbCanCauseKnockback
         {
            Send(what,@ApplyKnockback,#what=self,#knockback_power=Send(self,@GetSize));
         }
         if vbCanCauseBleed
         {
            Send(what,@ApplyBleed,#what=self,#bleed_power=Send(self,@GetSize));
         }
      }
      return;
   }

   KilledSomething(what=$,use_weapon=$)
   {
      if what = $
      {
         Debug("Bad info in killedsomething().");

         return;
      }

      % If we have a master, they are responsible for our kills.
      if poMaster <> $
      {
         if IsClass(poMaster,&Player)
         {
            Send(poMaster,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=TRUE);
         }

         if IsClass(what,&Player)
            AND IsClass(poMaster,&Player)
         {
            % If we killed an innocent, tell the master they're in trouble.
            if (NOT Send(poMaster,@CheckPlayerFlag,#flag=PFLAG_MURDERER))
               AND NOT (Send(what,@CheckPlayerFlag,#Flag=PFLAG_OUTLAW)
                  OR Send(what,@CheckPlayerFlag,#Flag=PFLAG_MURDERER))
            {
               Send(poMaster,@MsgSendUser,#message_rsc=vrMinion_trouble);
            }

            % Evil twins are dispelled by any player they kill.
            if IsClass(self,&EvilTwin)
            {
               Post(self,@Delete);
            }
         }

         % Our master handles the kill from here, since they
         % made us do it.
         return Send(poMaster,@KilledSomething,#what=what,
                     #use_weapon=use_weapon,#oMinionKiller=self);
      }

      % If this is an apparition, and it has no master,
      % the caster of the apparition acts as the master for
      % tracking the results of monster kills, but not any
      % accidental player kills (or player minion kills).
      if poApparitionCaster <> $
         AND IsClass(what,&Monster)
         AND (Send(what,@GetMaster) = $
            OR IsClass(Send(what,@GetMaster),&Monster))
      {
         return Send(poApparitionCaster,@KilledSomething,#what=what,
                     #use_weapon=use_weapon);
      }

      % If we don't have a master, proceed as normal.
      Send(Send(what,@GetOwner),@SomethingKilled,#what=self,#victim=what);

      if what = self
      {
         Post(what,@Killed,#what=self);
      }
      else
      {
         Send(what,@Killed,#what=self);
      }

      return;
   }

   CreateDeadBody(killer=$)
   {
      local oBody;

      oBody = $;

      if vrDead_icon <> $
      {
         oBody = Create(&DeadBody,
                        #victim=self,
                        #killer=killer,
                        #drawfx=viDead_drawfx,
                        #BodyTranslation = piColor_translation);
      }

      return oBody;
   }

   GetDeadName()
   {
      return vrDead_name;
   }
   
   GetDeadIcon()
   {
      return vrDead_Icon;
   }
   
   Killed(what=$)
   "The mob was just killed."
   {
      local i,val,oBody,hReputation,oHighestHurtMe, each_obj;

      % If the monster was just killed, assume it did itself in.
      if what = $
      {
         what = self;
      }

      Send(self,@ClearAllStatusEffects);
      
      Send(self,@ClearBombs);

      Send(self,@CancelCastingAnimation);

      if (viDefault_behavior & AI_NPC)
      {
         return;
      }
      
      poEventSpawner = $;
      
      if ptDrowningTimer <> $
      {
         DeleteTimer(ptDrowningTimer);
         ptDrowningTimer = $;
      }

      if poOwner <> $
      {
         % If a monster was the killer, and it has a master, set 'what'
         % to the master. This *should* be handled by the killer in
         % KilledSomething, but to be safe (and because quests are
         % checked here) we should check again for a master.
         if IsClass(what,&Monster)
            AND Send(what,@GetMaster) <> $
         {
            what = Send(what,@GetMaster);
         }

         oBody = Send(self,@CreateDeadBody,#killer=what);

         if oBody <> $
         {
            if IsClass(oBody,&DeadBody)
            {
               Send(oBody,@SetMonsterData,#lMonsterData=[GetClass(self),
                                   Send(self,@GetLoyalty),
                                   0,
                                   Send(self,@ReturnMaxHitPoints),
                                   Send(self,@GetChampStatus),
                                   Send(self,@GetSummoned)]);
               Send(oBody,@SetMasterWas,#oMaster=poMaster);
            }

            Send(poOwner,@NewHold,#what=oBody,#new_row=piRow,#new_col=piCol,
                  #fine_row=piFine_row,#fine_col=piFine_col,
                  #new_angle=Send(self,@GetAngle));
         }

         if vrSound_death <> $
         {
            Send(poOwner,@SomethingWaveRoom,#what=oBody,#wave_rsc=vrSound_death,
                  #flags=SOUND_RANDOM_PITCH);
         }

         if NOT Send(poOwner,@IsArena)
         {
            % Notify the quest engine, to check if a quest is affected -AJM
            Send(Send(SYS,@GetQuestEngine),@MonsterKilled,#dead_monster=self,
                  #killing_player=what,#corpse=oBody);

            Send(EVENTENGINE_OBJECT,@MonsterKilled,#dead_monster=self,
                  #killing_player=what,#corpse=oBody);

            if (piReputationGroup <> REP_NEUTRAL
               AND Send(SETTINGS_OBJECT,@GetMonsterFactionEnabled))
            {
               hReputation = Send(what,@GetReputationHash);
               
               % attempt to create a players rep hash if it does not exist
               if (hReputation=$)
               {
                  hReputation = Send(what,@CreateReputationHash);

                  if (hReputation = $)
                  {
                     Debug("Unable to get player reputation hash, not changing reputation");
                  }
               }
               
               % now actually do the rep chenge unless there is no hash
               if (hReputation <> $)
               {
                  val=GetTableEntry(hReputation,piReputationGroup);
                  if (val <> $)
                  {
                     --val;
                     if (val >= -20000)
                     {
                        DeleteTableEntry(hReputation,piReputationGroup);
                        AddTableEntry(hReputation,piReputationGroup,val);
                     }
                  }
                  else
                  {
                     AddTableEntry(hReputation,piReputationGroup,-1);
                  }

                  %Send(what,@MsgSendUser,
                  %   #message_rsc=monster_faction_negative_msg,
                  %   #parm1=Send(self,@GetMonsterFactionRSC,
                  %            #faction=piReputationGroup));

                  % Adjust reputation with enemies of this monster
                  foreach i in plReputationEnemies
                  {
                     val=GetTableEntry(hReputation,i);
                     if (val <> $)
                     {
                        ++val;
                        if (val <= 20000)
                        {
                           DeleteTableEntry(hReputation,i);
                           AddTableEntry(hReputation,i,val);
                        }
                     }
                     else
                     {
                        AddTableEntry(hReputation,i,1);
                     }

                     %Send(what,@MsgSendUser,
                     %#message_rsc=monster_faction_positive_msg,
                     %#parm1=Send(self,@GetMonsterFactionRSC,#faction=i));
                  }
               }
            }

            oHighestHurtMe = Send(self,@GetHighestHurtMeRecentlyBattler);
            if oHighestHurtMe <> $
            {
               piLadderID = Send(oHighestHurtMe,@GetLadderID);
            }
            else
            {
               piLadderID = Send(what,@GetLadderID);
            }
            if piLadderID = $
            {
               piLadderID = 0;
            }
            
            foreach i in Send(self,@GetHolderActive)
            {
               each_obj = Send(self,@HolderExtractObject,#data=i);
               if IsClass(each_obj,&Item)
               {
                  Send(each_obj,@SetLadderID,#value=piLadderID);
               }
            }
            foreach i in Send(self,@GetHolderPassive)
            {
               each_obj = Send(self,@HolderExtractObject,#data=i);
               if IsClass(each_obj,&Item)
               {
                  Send(each_obj,@SetLadderID,#value=piLadderID);
               }
            }
            
            Send(self,@CreateTreasure,#who=what,#corpse=oBody,#ladderID=piLadderID);
         }

         % Delete here so we don't accidentally "kill" then delete system
         %  template monsters.
         Send(self,@Delete);
      }

      return;
   }

   GetMonsterFactionRSC(faction = $)
   {
      local factionRSC;

      switch(faction)
      {
         case REP_FAROL:
            factionRSC = monster_faction_farol;
            break;

         case REP_ORC:
            factionRSC = monster_faction_orc;
            break;

         case REP_TROLL:
            factionRSC = monster_faction_troll;
            break;

         case REP_FARNOHL:
            factionRSC = monster_faction_farnohl;
            break;

         case REP_LICH:
            factionRSC = monster_faction_lich;
            break;

         case REP_PSAVAR:
            factionRSC = monster_faction_psavar;
            break;

         case REP_KKAVAR:
            factionRSC = monster_faction_kkavar;
            break;

         case REP_CTAVAR:
            factionRSC = monster_faction_ctavar;
            break;

         case REP_FEY_GOOD:
            factionRSC = monster_faction_fey_good;
            break;

         case REP_FEY_EVIL:
            factionRSC = monster_faction_fey_evil;
            break;

         case REP_FROGMEN:
            factionRSC = monster_faction_frogmen;
            break;

         case REP_HERETIC:
            factionRSC = monster_faction_heretic;
            break;

         case REP_UNDEAD:
            factionRSC = monster_faction_undead;
            break;

         default:
            factionRSC = monster_faction_unspecified;
            break;
      }
      return factionRSC;
   }

   %%% SERVICE MESSAGES

   Repair()
   "This is just a stub"
   {
      return;
   }

   Offer(what = $,item_list = $)
   "Offer the player money in exchange for their goods - MOB_BUYER"
   {
      local i, iValue_offered, iAdd, x, y;

      % The Faction Pricing bonus was selling items to NPCs at higher prices
      % than the new price.  This has been taken out.

      if (viAttributes & MOB_BUYER
         OR viAttributes & MOB_RECEIVE)
      {
         iValue_offered = 0;
         foreach i in item_list
         {
            x = Send(i,@GetValue) * (100 - 10*viMerchant_markup) / 100;
            iAdd = Bound(x,1,$);

            iValue_offered = iValue_offered + iAdd;
         }

         poCustomer = what;

         plOffer_items = [ Create(&Money,#number=iValue_offered,#ladderID=Send(what,@GetLadderID)) ];
         Send(what,@CounterOffer,#item_list=plOffer_items);
         ptCancelOffer = CreateTimer(self,@CancelOfferTimer,viCancel_offer_time);
      }
      else if IsClass(what,&DM)
      {
         Send(what,@CounterOffer,#item_list=$);
      }

      return;
   }

   CancelOfferTimer()
   {
      ptCancelOffer = $;

      Post(self,@SayToOne,#target=poCustomer,#message_rsc=Lm_buyer_timeout);
      Send(poCustomer,@OfferCanceled);
      Send(self,@OfferCanceled);

      return;
   }

   OfferCanceled()
   {
      % if called from timer, no timer left.  If user cancelled, delete timer.

      if ptCancelOffer <> $
      {
         DeleteTimer(ptCancelOffer);
      }

      ptCancelOffer = $;

      poCustomer = $;
      plOffer_items = $;

      return;
   }

   AcceptOffer()
   "Transfer the purchased merchandise - MOB_BUYER"
   {
      local i,oHolder,lTake_items;

      % set the stuff where the user can get to it
      oHolder = Send(SYS,@GetSystemHolder2);
      foreach i in plOffer_items
      {
         Send(oHolder,@NewHold,#what=i);
         if IsClass(i,&Money)
         {
            Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=Send(i,@GetNumber));
         }
      }

      % take stuff the user put there
      oHolder = Send(SYS,@GetSystemHolder1);
      foreach lTake_items in [ Send(oHolder,@GetHolderActive),
                           Send(oHolder,@GetHolderPassive) ]
      {
         foreach i in lTake_items
         {
            Send(self,@NewHold,#what=i);
         }
      }

      % kill the cancel offer timer
      Send(self,@OfferCanceled);

      return TRUE;
   }

   VaultDeposit(who=$,lItems=$)
   {
      local i, oVault, iFee, oMoney, iCash;

      if not Send(self,@MobIsVaultman)
      {
         return;
      }

      oVault = Send(SYS,@FindVaultByNum,#num=Send(self,@GetVaultNum));
      if oVault = $
      {
         Debug("Nil vault!");

         return;
      }

      iFee = 0;
      foreach i in lItems
      {
         % Can't store anything without any bulk, such as gold
         if Send(i,@GetBulk) <= 0 
         {
            Send(self,@SayToOne,#message_rsc=vaultman_nogold,#target=who,
                 #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));

            return FALSE;
         }

         if NOT Send(who,@ReqLeaveHold,#what=i)
         {
            Send(self,@SayToOne,#message_rsc=vaultman_nocursed,#target=who,
                 #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));

            return FALSE;            
         }

         if NOT Send(i,@CanBeStoredInVault)
         {
            Send(self,@SayToOne,#message_rsc=vaultman_cant_part,#target=who,
                 #parm1=Send(i,@GetName));

            return FALSE;            
         }

         iFee = iFee + Send(self,@GetVaultDepositFee,#what=i,#who=who);
      }

      oMoney = Send(who,@GetMoneyObject);
      if oMoney = $
      {
         % No cash.
         iCash = 0;
      }
      else
      {
         iCash = Send(oMoney,@GetValue);
      }

      if iCash < iFee AND iFee <> 0
      {
         Send(self,@SayToOne,#target=who,#message_rsc=vaultman_nodeposit_cash,
              #parm1=iFee);

         return;
      }               

      % this checks bulk of deposited items.
      if NOT Send(oVault,@CanDepositItems,#who=who,#lItems=lItems)
      {
         Send(self,@SayToOne,#message_rsc=vaultman_fullvault,#target=who);

         return FALSE;            
      }

      Send(who,@MadeItemDeposit,#with=self,#lItems=lItems);
      
      % passed all checks.  put the stuff in.      
      Send(oVault,@DepositItems,#lItems=lItems,#who=who);

      if iFee <> 0
      {
         Send(oMoney,@SubtractNumber,#number=iFee);  
         Send(self,@SayToOne,#message_rsc=vaultman_Thanks_amount,#target=who,
              #parm1=iFee);
      }
      else
      {
         Send(self,@SayToOne,#message_rsc=vaultman_deposit_thanks,#target=who);
      }

      Send(self,@AffectMood,#why=MOODMOD_VAULT_DEPOSIT);

      return;
   }

   GetVaultDepositFee(what=$)
   "Default cost is 1 gp per stone."
   {
      return Send(what,@GetBulk);
   }

   GetVaultRetrievalFee(what=$)
   "Default cost no cost.  However, expensive places can charge more."
   {
      return 0;
   }

   VaultWithdraw(what=$,lItems=$,number_list = $)
   {
      local i, j, iFee, iCash, lStored, oVault, iBulk, oMoney, bFound,
            oSafeBox, lNumbers, iCount, bFailed;

      if what = $ OR lItems = $
      {
         return;
      }

      oMoney = Send(what,@GetMoneyObject);
      if oMoney = $
      {
         % No cash.
         iCash = 0;
      }
      else
      {
         iCash = Send(oMoney,@GetValue);
      }

      oVault = Send(SYS,@FindVaultByNum,#num=Send(self,@GetVaultNum));
      oSafeBox = Send(oVault,@GetPlayerSafeBox,#who=what);

      if oSafeBox = $
      {
         Send(self,@SayToOne,#target=what,#message_rsc=vaultman_noAccount);

         return;
      }

      iFee = 0;
      iBulk = 0;
      iCount = 0;
      bFound = FALSE;

      % Make sure the player really has this item in storage.
      foreach i in lItems
      {
         foreach j in Send(oSafeBox,@GetHolderPassive)
         {
            if i = j
            {
               bFound = TRUE;
            }

            if IsClass(i,&NumberItem)
               AND GetClass(i) = GetClass(j)
            {
               % Check if we have a valid number list. Check is done here
               % as we don't need a number list for non-number items.
               if number_list = $
               {
                  return;
               }

               iCount = iCount + 1;
               if Nth(number_list,iCount) > Send(j,@GetNumber)
               {
                  Send(self,@SayToOne,#target=what,
                        #message_rsc=vaultman_not_enough,
                        #parm1=Send(i,@GetName));

                  return;
               }

               bFound = TRUE;
            }
         }

         if NOT bFound
         {
            Post(self,@SayToOne,#target=what,#message_rsc=vaultman_dont_have,
                 #parm1=Send(i,@getindef),#parm2=Send(i,@GetName));

            return;
         }

         iFee = iFee + Send(self,@GetVaultRetrievalFee,#what=i);

         if IsClass(i,&NumberItem)
            AND number_list <> $
            AND Length(number_list) >= iCount
         {
            iBulk = iBulk + ((Send(i,@GetBulk) * nth(number_list,iCount))
                             / Send(i,@GetNumber));
         }
         else
         {
            iBulk = iBulk + Send(i,@GetBulk);
         }
      }

      % Does the player have enough ca$h?
      if iCash < iFee AND iFee <> 0
      {
         Send(self,@SayToOne,#target=what,
              #message_rsc=vaultman_nowithdraw_cash);

         return;
      }         

      %if Send(what, @GetBulkMax) <> $ AND
      %   (iBulk + Send(what,@GetBulkHold)) > Send(what,@GetBulkMax)
      %{
      %   Send(self,@SayToOne,#target=what,#message_rsc=vaultman_no_room);
      %
      %   return;
      %}   
      
      % The next line added to handle player specified amounts
      lNumbers = number_list;
      bFailed = FALSE;

      % At this point, we're pretty sure it's all legal.      
      foreach i in lItems
      {
         % Don't bother calling ReqMewHold.  It just checks weight,
         % which you already know is legal.
         % Adding this check would be difficult.
         if Send(i,@ReqNewOwner,#what=what)
         {
            if IsClass(i,&NumberItem)
            {               
               if NOT Send(oVault,@WithdrawFromStorage,#what=i,#who=what,
                    #count=First(lNumbers))
               {
                  bFailed = TRUE;
                  break;
               }

               lNumbers = Rest(lNumbers);
            }
            else
            {
               if NOT Send(oVault,@WithdrawFromStorage,#what=i,#who=what,#count=1)
               {
                  bFailed = TRUE;
                  break;
               }
            }
            
         }
      }

      if iFee <> 0
      {
         Send(oMoney,@SubtractNumber,#number=iFee);
         if bFailed
         {
            Send(self,@SayToOne,#target=what,#message_rsc=vaultman_withdraw_failed);
         }
         else
         {
            Send(self,@SayToOne,#message_rsc=vaultman_Thanks_amount,#target=what,
              #parm1=iFee);
         }
      }
      else
      {
         if bFailed
         {
            Send(self,@SayToOne,#target=what,#message_rsc=vaultman_withdraw_failed);
         }
         else
         {
            Send(self,@SayToOne,#target=what,#message_rsc=vaultman_thanks);
         }
      }

      return;
   }

   BankBalance(who=$)
   {
      local oBank;

      if NOT Send(self,@MobIsBanker)
      {
         return;
      }

      if Send(self,@GetBankNum) = $
      {
         Debug("BAD: Banker has no bankID",vrname,self);

         return;
      }

      oBank = Send(SYS,@FindBankByNum,#num=Send(self,@GetBankNum));
      Post(who,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
           #string=Lm_bnkr_balance,#parm1=Send(oBank,@GetAccount,#what=who));

      return;
   }

   ReportBankBalance(who=$,number=0)
   {
      local oBank, lTops, oSnoop;

      if NOT Send(self,@MobIsBanker)
      {
         return FALSE;
      }

      oSnoop = Send(SYS,@GetInvestigator);
      if oSnoop = $
      {
         return FALSE;
      }

      if number = 0 AND who = $
      {
         return FALSE;
      }

      if Send(self,@GetBankNum) = $
      {
         Debug("BAD: Banker has no bankID",vrname,self);

         return FALSE;
      }

      oBank = Send(SYS,@FindBankByNum,#num=Send(self,@GetBankNum));

      if who <> $
      {
         Send(oSnoop,@MsgSendUser,#message_rsc=monster_report_balance,
              #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName),
              #parm3=Send(who,@GetUserName),#type3=STRING_RESOURCE,
              #parm4=Send(oBank,@GetAccount,#what=who));
      }
      else
      {
         lTops = Send(oBank,@FindTopAccounts,#number=number);
         foreach who in lTops
         {
            Send(oSnoop,@MsgSendUser,#message_rsc=monster_report_balance,
               #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName),
               #parm3=Send(who,@GetUserName),#type3=STRING_RESOURCE,
               #parm4=Send(oBank,@GetAccount,#what=who));
         }
      }

      return TRUE;
   }

   BankDeposit(who=$, amount = 0)
   {
      local oMoney, oBank, iBankAmt;

      if NOT Send(self,@MobIsBanker)
      {
         return;
      }

      if amount <= 0
      {
         return;
      }

      if Send(self,@GetBankNum) = $
      {
         Debug("BAD: Banker has no bankID",vrname,self);

         return;
      }

      oMoney = Send(who,@GetMoneyObject);
      if oMoney = $
      {
         Post(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
              #string=Lm_bnkr_not_enough_deposit,#parm1=0);

         return;
      }

      if Send(oMoney,@GetValue) < amount
      {
         Post(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
              #string=Lm_bnkr_not_enough_deposit,
              #parm1=Send(oMoney,@GetValue));

         return;
      }

      oBank = Send(SYS,@FindBankByNum,#num=Send(self,@GetBankNum));
      iBankAmt = Send(oBank,@GetAccount,#what=who);

      % Check for integer overflow.
      if (iBankAmt = MAX_KOD_INT)
      {
         Post(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
              #string=Lm_bnkr_acct_full);

         return;
      }
      else if (iBankAmt + amount < 0)
      {
         amount = MAX_KOD_INT - iBankAmt;
         % Re-check amount, just to be sure.
         if Send(oMoney,@GetValue) < amount
         {
            Debug("Error modifying bank deposit amount for ",
                  Send(who,@GetTrueName),"amt: ",amount," bank amt: ",iBankAmt);

            return;
         }

         Post(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
               #string=Lm_bnkr_acct_almost_full,#parm1=amount);
      }

      Send(oMoney,@SubtractNumber,#number=amount);
      Send(oBank,@DepositAccount,#what=who,#amount=amount);

      Post(who,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
           #string=Lm_bnkr_did_deposit,
           #parm1=Send(oBank,@GetAccount,#what=who));
      
      Post(who,@MadeMoneyDeposit,#with=self,#amount=amount);

      Send(self,@AffectMood,#why=MOODMOD_BANK_DEPOSIT);

      if Send(SYS,@IsSuspect,#who=who)
      {
         Send(self,@ReportBankBalance,#who=who);
      }

      return;
   }

   BankWithdraw(who = $, amount = 0)
   {
      local iPlayerAmt, iBankAmt, oMoney, oBank;

      if NOT Send(self,@MobIsBanker)
      {
         return;
      }

      if amount < 0
      {
         return;
      }

      if Send(self,@GetBankNum) = $
      {
         Debug("BAD: Banker has no bankID",vrname,self);

         return;
      }

      oBank = Send(SYS,@FindBankByNum,#num=Send(self,@GetBankNum));
      iBankAmt = Send(oBank,@WithdrawAccount,#what=who);

      if iBankAmt = 0
      {
         Post(who,@SomeoneSaid,#what=self,#string=Lm_bnkr_no_account,
              #type=SAY_RESOURCE);

         return;
      }

      if amount > iBankAmt
      {
         Send(oBank,@DepositAccount,#what=who,#amount=iBankAmt);
         Post(who,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
              #string=Lm_bnkr_not_enough_withdraw,#parm1=iBankAmt);

         return;
      }

      oMoney = Send(who,@GetMoneyObject);
      if oMoney = $
      {
         oMoney = Create(&Money,#number=amount,#ladderID=Send(who,@GetLadderID));
         Send(who,@NewHold,#what=oMoney);
      }
      else if (Send(oMoney,@GetNumber) + amount) <= 0
      {
         iPlayerAmt = Send(oMoney,@GetNumber);
         if iPlayerAmt = MAX_KOD_INT
         {
            Send(oBank,@DepositAccount,#what=who,#amount=iBankAmt);
            Post(who,@SomeoneSaid,#what=self,#string=Lm_bnkr_player_all_full,
                  #type=SAY_RESOURCE);

            return;
         }
         else if (iPlayerAmt + amount) <= 0
         {
            amount = MAX_KOD_INT - iPlayerAmt;
            Post(who,@SomeoneSaid,#what=self,#string=Lm_bnkr_player_full,
                  #type=SAY_RESOURCE,#parm1=amount);

            if amount > iBankAmt
            {
               Debug("Error giving player ",Send(who,@GetTrueName),amount,
                  " shillings from total ",iBankAmt,"!. Player has ",iPlayerAmt);
               Send(oBank,@DepositAccount,#what=who,#amount=iBankAmt);

               return;
            }
         }
      }
      else
      {
         Send(oMoney,@AddNumber,#number=amount);
      }

      Send(oBank,@DepositAccount,#what=who,#amount=iBankAmt-amount);

      % Send this message even if we gave the almost full one - players are
      % used to seeing this message on a successful transaction.
      Post(who,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
            #string=Lm_bnkr_did_withdraw,#parm1=amount);

      Send(self,@AffectMood,#why=MOODMOD_BANK_WITHDRAWAL);

      if Send(SYS,@IsSuspect,#who=who)
      {
         Send(self,@ReportBankBalance,#who=who);
      }

      return;
   }

   Buy(what = $,item_list = $,number_list = $)
   "Handle things having to do with mobs who have stuff to sell. "
   "This is used for both teachers and sellers"
   {
      local i, j, bFound, oBuy, oMoney, iPrice, iPriceOne, lNumbers,
            iAmount, oItemAtt, iCan_hold, oSplit; 

      % Ensure that buyer and seller are in the same room
      if Send(what,@GetOwner) <> poOwner
      {
         Debug("ALERT! ",Send(what,@GetTrueName),what," tried to buy items "
               "from ",Send(self,@GetTrueName)," while in distant RID ",
               Send(Send(what,@GetOwner),@GetRoomNum));

         return FALSE;
      }

      if NOT Send(self,@IsCustomerOkay,#who=what)
      {
         return;
      }

      if Send(self,@MobIsVaultman)
      {
         Send(self,@VaultWithdraw,#what=what,#lItems=item_list,
               #number_list=number_list);
         Send(self,@AffectMood,#why=MOODMOD_VAULT_WITHDRAWAL);

         return;
      }

      % The next line added to handle player specified amounts
      lNumbers = number_list;

      % Walk the objects the user selected as wanting to purchase from
      % our Sale list
      foreach i in item_list
      {
         % Find the dude's money.  Do this each time in case we exactly use it
         % up.

         % Get the amount of money for standard amount
         oMoney = Send(what,@GetMoneyObject);

         % Get the price for that amount
         iPriceOne = Send(self,@GetPrice,#what=i,#who=what);

         % Init iPrice to the cost of one item.
         iPrice = iPriceOne;

         if IsClass(i,&Item)
         {
            % If the item is an item (not a skill)
            if IsClass(i,&NumberItem)
            {
               % Check if we have a valid number list. Check is done here
               % as we don't need a number list for non-number items.
               if lNumbers = $
               {
                  continue;
               }
               % See how many the player wants.
               iAmount = First(lNumbers);

               if (iAmount = $)
               {
                  iAmount = 1;
               }

               % Make sure requested number of items is within the
               % limits. If selling from inventory, we can only sell
               % as many as we have.
               if vbSellFromInventory
               {
                  iAmount = Bound(iAmount,1,Send(i,@GetNumber));
               }
               else
               {
                  iAmount = Bound(iAmount,1,MAX_BUY_AMOUNT);
               }

               % Make sure cost for 1 item is at least one gold coin.
               iPriceOne = Bound(iPriceOne, 1, $);

               % Now figure price
               iPrice = iPriceOne * iAmount;

               % Make sure we have a price of at least one gold coin
               iPrice = Bound(iPrice, 1, $);

               % Move to next number in the list.
               lNumbers = Rest(lNumbers);
            }
         }

         % Does player have enough money to buy it?
         if oMoney = $ OR Send(oMoney,@GetValue) < iPrice
         {
            Post(poOwner,@SomeoneSaid,#what=self,#string=vrMrcnt_too_costly,
                  #type=SAY_RESOURCE,#parm1=Send(i,@GetDef),
                  #parm2=Send(i,@GetName));

            continue;
         }

         % Make sure the item is really for sale from this mob.
         bFound = FALSE;
         foreach j in Send(self,@GetForSale,#who=what)
         {
            if i = j
            {
               bFound = TRUE;
            }
         }

         if NOT bFound
         {
            Post(poOwner,@SomeoneSaid,#what=self,
                  #string=Lm_mrcnt_not_selling,#type=SAY_RESOURCE);

            continue;
         }

         if IsClass(i,&Item)
         {
            if IsClass(i,&NumberItem)
            {
               oBuy = Create(GetClass(i),#number=iAmount,#ladderID=Send(what,@GetLadderID));
            }
            else
            {
               % Selling the item itself, or a copy?
               if vbSellFromInventory
               {
                  oBuy = i;
               }
               else
               {
                  oBuy = Create(GetClass(i),#model=i,#ladderID=Send(what,@GetLadderID),#level=viLevel,#mob=self);
               }
            }

            if Send(what,@ReqNewHold,#what=oBuy)
               AND Send(oBuy,@ReqNewOwner,#what=what)
            {
               % Get rid of the item from our inventory?
               if vbSellFromInventory
               {
                  if IsClass(i,&NumberItem)
                  {
                     % Sold all of the item?
                     if Send(i,@GetNumber) = iAmount
                     {
                        SetNth(plFor_Sale,1,DelListElem(First(plFor_Sale),i));
                     }

                     Send(i,@SubtractNumber,#Number=iAmount);
                  }
                  else
                  {
                     % Start the go bad timer.
                     if IsClass(i,&SpellItem)
                     {
                        Send(i,@StartGoBadTimer);
                     }

                     SetNth(plFor_Sale,1,DelListElem(First(plFor_Sale),i));
                  }
               }

               % Add item to buyer's inventory
               Send(what,@NewHold,#what=oBuy);
               Send(what,@BoughtAnItem,#bought_from=self,#what=oBuy);
               Send(oMoney,@SubtractNumber,#number=iPrice);
               Send(self,@RemoveFromConditionalList,
                     #obj=Send(self,@GetObjectOnConditionalList,
                     #class=GetClass(i)));

               Send(self,@AffectMood,#why=MOODMOD_SELL_ITEM,#what=oBuy);

               if Send(oBuy,@HasAttribute,#ItemAtt=IA_SELL_INFO)
               {
                  oItemAtt = Send(oBuy,@GetAttributeData,
                                    #ItemAtt=IA_SELL_INFO);
                  Post(poOwner,@SomeoneSaid,#what=self,#string=Nth(oItemAtt,2),
                        #type=SAY_RESOURCE);
               }
            }
            else
            {
               % Check if this is a number item we're buying too much of.
               if IsClass(oBuy,&NumberItem)
                  AND Send(what,@GetNumberCanHold,#what=oBuy) > 0
               {
                  iCan_hold = Send(what,@GetNumberCanHold,#what=oBuy);
                  if iCan_hold > 0
                  {
                     oSplit = Send(oBuy,@Split,#number=iCan_hold);
                     if Send(oBuy,@ReqNewOwner,#what=oSplit)
                     {
                        Send(oMoney,@SubtractNumber,
                              #number=iPriceOne * Send(oSplit,@GetNumber));
                        Send(i,@SubtractNumber,#Number=Send(oSplit,@GetNumber));
                        Send(what,@NewHold,#what=oSplit);
                        Send(what,@BoughtAnItem,#bought_from=self,#what=oSplit);
                        Post(poOwner,@SomeoneSaid,#what=self,
                              #string=Lm_mrcnt_can_give_some,
                              #type=SAY_RESOURCE,#parm1=Send(oBuy,@GetDef),
                              #parm2=Send(oBuy,@GetName));
                              
                        Send(self,@RemoveFromConditionalList,
                           #obj=Send(self,@GetObjectOnConditionalList,
                           #class=GetClass(i)));

                        Send(self,@AffectMood,#why=MOODMOD_SELL_ITEM,#what=oBuy);

                        if Send(oBuy,@HasAttribute,#ItemAtt=IA_SELL_INFO)
                        {
                           oItemAtt = Send(oBuy,@GetAttributeData,
                                           #ItemAtt=IA_SELL_INFO);
                           Post(poOwner,@SomeoneSaid,#what=self,
                               #string=Nth(oItemAtt,2),
                               #type=SAY_RESOURCE);
                        }
                        Send(oBuy,@Delete);
                     }
                  }
               }
               else
               {
                  % Buyer can't accept the item for some reason.
                  Post(poOwner,@SomeoneSaid,#what=self,#string=Lm_mrcnt_cant_give,
                        #type=SAY_RESOURCE,#parm1=Send(oBuy,@GetDef),
                        #parm2=Send(oBuy,@GetName));
                  Send(oBuy,@Delete);
               }
            }
         }
         else
         {
            % It's a skill or spell which we know to be legal to "sell"
            % so go ahead and add it....
            if IsClass(i,&Skill)
            {
               Send(what,@AddSkill,#num=Send(i,@GetSkillNum));
               Send(oMoney,@SubtractNumber,#number=iPrice);
            }
            else if IsClass(i,&Spell)
            {
               Send(what,@AddSpell,#num=Send(i,@GetSpellNum));
               Send(self,@TaughtPlayerSpell,#who=what,#num=Send(i,@GetSpellNum));
               Send(oMoney,@SubtractNumber,#number=iPrice);
            }
            else if IsClass(i,&Monster)
            {
               if Send(what,@CanControlNewMinion,#oMonster=i,#bCharming=FALSE)
               {
                  SetNth(plFor_Sale,1,DelListElem(First(plFor_Sale),i));
                  Send(i,@SetMaster,#oMaster=what);
                  Send(poOwner,@NewHold,#what=i,
                                        #new_row=Send(what,@GetRow),
                                        #new_col=Send(what,@GetCol),
                                        #fine_row=Send(what,@GetFineRow),
                                        #fine_col=Send(what,@GetFineCol));
                                     
                     % Add this creature to their minion list
                     Send(what,@NewControlledMinion,#minion=i);

                     % Set initial minion behavior
                     Send(i,@ResetBehaviorFlags);
                     Send(i,@SetBehaviorFlag,#flag=AI_MOVE_FOLLOW_MASTER,#value=TRUE);
                     Send(i,@SetBehaviorFlag,#flag=AI_FIGHT_AGGRESSIVE,#value=FALSE);
                     Send(i,@SetBehaviorFlag,#flag=AI_FIGHT_NEWBIESAFE);
                     Send(i,@SetBehaviorFlag,#flag=AI_FIGHT_MONSTERS);
                     Send(Send(SYS,@FindSpellByNum,#num=SID_CREATURE_BINDING),@DoSpell,#what=what,
                                                                                       #oTarget=i,
                                                                                       #iDuration=$,#report=FALSE,#iSpellPower=15);
                     Send(oMoney,@SubtractNumber,#number=iPrice);
                     Post(poOwner,@SomeoneSaid,#what=self,#string=monster_jailer_sold_to_you,#type=SAY_RESOURCE);
               }
               else
               {
                  Post(poOwner,@SomeoneSaid,#what=self,#string=monster_jailer_you_cannot_control_it,#type=SAY_RESOURCE);
               }
            }
         }
      }

      Send(self,@ItemBoughtHook,#buyer=what);

      return;
   }

   ItemBoughtHook(buyer = $)
   "Hook called after someone has bought something from us"
   {
      return;
   }

   %%% Utility messages

   GetOccupation()
   {
      return viOccupation;
   }

   GainHealthNormal(amount = $, precision = FALSE)
   "For when monsters heal themselves or each other."
   {
      local iMantled, iMantledDivisor;

      if amount = $
      {
         return 0;
      }

      if NOT precision
      {
         amount = amount * 100;
      }

      iMantled = Send(self,@GetStatusEffect,#type=STATUS_MANTLED);
      if iMantled > 0
      {
         iMantledDivisor = Send(SETTINGS_OBJECT,
                            @GetElementalMultiple,#type=STATUS_MANTLED);
         amount = amount - (iMantled/iMantledDivisor)*100;
      }

      piHit_points = Bound(piHit_points+amount,1,piMax_hit_points*100);

      return 0;
   }

   GainHealthNormalAndReportGained(amount = $, precision = FALSE)
   {
      local iMantled, iMantledDivisor, iInitial;

      if amount = $
      {
         return 0;
      }

      if NOT precision
      {
         amount = amount * 100;
      }

      iMantled = Send(self,@GetStatusEffect,#type=STATUS_MANTLED);
      if iMantled > 0
      {
         iMantledDivisor = Send(SETTINGS_OBJECT,
                            @GetElementalMultiple,#type=STATUS_MANTLED);
         amount = amount - (iMantled/iMantledDivisor)*100;
      }

      iInitial = piHit_points;
      piHit_points = Bound(piHit_points+amount,1,piMax_hit_points*100);

      return piHit_points - iInitial;
   }

   LoseHealth(amount = $, decay = FALSE, precision = FALSE)
   {
      if NOT precision
      {
         amount = amount*100;
      }

      piHit_points = Bound(piHit_points - amount,1,$);

      return;
   }

   NewMaxMana(amount=0)
   {
      local iPrev_max;

      iPrev_max = piMax_mana;
      piMax_Mana = piMax_mana + amount;

      return (piMax_mana - iPrev_max);
   }

   CalculateManaTime()
   "Calculate # of milliseconds until monster will gain a mana point."
   {
      local iTime, oSpell, i;

      % Old system had monsters regenerating 1 mana point per second.
      % Do the same here for now.
      if piMana > piMax_mana
      {
         iTime = BOOST_DECAY_TIME;
      }
      else
      {
         iTime = 1000;
      }

      if iTime = 1000
      {
         foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
         {
            iTime = Send(Nth(i,2),@ModifyManaRegenTime,
                                 #state=Nth(i,3),#regen=iTime);
         }
      }

      return iTime;
   }

   MonsterCanCastSpell()
   "Returns FALSE if a monster can't currently cast a spell for some reason."
   {
      if (piBehavior & AI_NOFIGHT)
      {
         return FALSE;
      }

      if ptSpellCastTimer <> $
      {
         % Hasn't been long enough. In MS.
         return FALSE;
      }

      return TRUE;
   }

   MonsterCastAnimation(iSpellNum=$)
   "If a monster has a special cast animation, call this."
   {
      piAnimation = ANIM_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = ANIM_NONE;

      return;
   }

   HitPointThresholdDamage()
   {
      local i, iThreshold, rDamage_report, each_obj;

      iThreshold = piHit_points / (piMax_hit_points * 20);

      if iThreshold >= 4
      {
         return;
      }
      else if iThreshold = 3
      {
         rDamage_report = vrFirst_damage_level;
      }
      else if iThreshold = 2
      {
         rDamage_report = vrSecond_damage_level;
      }
      else if iThreshold = 1
      {
         rDamage_report = vrThird_damage_level;
      }
      else
      {
         rDamage_report = vrFourth_damage_level;
      }

      foreach i in Send(poOwner,@GetHolderActive)
      {
         each_obj = First(i);
         if IsClass(each_obj,&User)
            AND Send(each_obj,@GetKillTarget) = self
            AND NOT IsClass(self,&Marauder)
         {
            Post(each_obj,@MsgSendUser,#what=self,#message_rsc=rDamage_report,
                  #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
         }
      }

      return;
   }

   HitPointThresholdHeal()
   {
      return;
   }

   HealHitPoint()
   {
      local iPercentClass, i, each_obj, iModifiedGain;

      if piHit_points >= piMax_Hit_points * 100
      {
         return;
      }

      % Start with full 100% of hit point
      iModifiedGain = 100;

      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
      {
         iModifiedGain = Send(Nth(i,2),@ModifyHealthRegenAmount,
                                 #state=Nth(i,3),#regen=iModifiedGain);
      }

      % Don't drain below zero
      if iModifiedGain < 0
         AND piHit_points <= 100
      {
         iModifiedGain = 0;
      }

      % We set a mark to see if the healing changes our threshold
      iPercentClass = piHit_points / (piMax_Hit_points * 20);
      piHit_points = piHit_points + iModifiedGain;
      if iPercentClass <> (piHit_points / (piMax_Hit_points * 20))
      {
         Send(self,@HitPointThresholdHeal);

         foreach i in Send(poOwner,@GetHolderActive)
         {
            each_obj = First(i);
            if IsClass(each_obj,&User)
               AND Send(each_obj,@GetKillTarget) = self
            {
               Post(each_obj,@MsgSendUser,#what=self,
                     #message_rsc=vrMonster_healing,
                     #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
            }
         }
      }

      return;
   }

   CheckWhyWanted(obj=$, who=$)
   {
      local value,oMoney;

      if IsClass(obj,&SignetRing)
      {
         % Does the signet want this mob? (or vice versa).
         if Send(obj,@GetRingOwner) = self
         {
            Send(Send(SYS,@GetLibrary),@UnregisterSignet,#newring=obj);
            Send(Send(SYS,@GetLibrary),@SignetDelivered,#who=who);
            Post(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
                 #string=LS_Signet_returned);
            Send(obj,@NewOwner,#what=self);

            % Have the ring handle the reward.
            Send(obj,@RewardReturner,#who=who);

            return TRUE;
         }
         else
         {
            Post(poOwner,@SomeoneSaid,#what=self,
                 #string=LS_Signet_wrong,#type=SAY_RESOURCE,
                 #parm1=Send(Send(obj,@GetRingOwner),@GetDef),
                 #parm2=Send(Send(obj,@GetRingOwner),@GetName));

            return FALSE;
         }
      }

      Post(poOwner,@SomeoneSaid,#what=self,#string=LS_wanted_keep,
           #type=SAY_RESOURCE);

      return TRUE;
   }

   ShowDesc(iHitPoint_Percent = $)
   "Adds max HP that can be gained from monster, followed by its condition."
   {
      local iHit_Percent, rMonster_condition, rChampionStatus, iBindingLevel, rBindingLevel,
            rMobDef, rMobName, rMasterIndef, rMasterName;

      if iHitPoint_Percent = $
      {
         iHit_Percent = piHit_points / piMax_hit_points;
      }
      else
      {
         iHit_Percent = iHitPoint_Percent;
      }
      
      iBindingLevel = piLoyalty/LOYALTY_PER_BINDING_LEVEL;
      if poMaster = $
         OR piLoyalty = 0
      {
         rMobDef = minion_bind_level_blank;
         rMobName = minion_bind_level_blank;
         rMasterIndef = minion_bind_level_blank;
         rMasterName = minion_bind_level_blank;
      }
      else
      {
         rMobDef = Send(self,@GetCapDef);
         rMobName = Send(self,@GetName);
         rMasterIndef = Send(poMaster,@GetIndef);
         rMasterName = Send(poMaster,@GetName);
      }

      switch(iBindingLevel)
      {
         case 0:
            if piLoyalty = 0
            {
               rBindingLevel = minion_bind_level_nothing;
            }
            else
            {
               rBindingLevel = minion_bind_level_0;
            }
            break;
         case 1:
            rBindingLevel = minion_bind_level_1;
            break;
         case 2:
            rBindingLevel = minion_bind_level_2;
            break;
         case 3:
            rBindingLevel = minion_bind_level_3;
            break;
         case 4:
            rBindingLevel = minion_bind_level_4;
            break;
         case 5:
            rBindingLevel = minion_bind_level_5;
            break;
         case 6:
            rBindingLevel = minion_bind_level_6;
            break;
         case 7:
            rBindingLevel = minion_bind_level_7;
            break;
         case 8:
            rBindingLevel = minion_bind_level_8;
            break;
         case 9:
            rBindingLevel = minion_bind_level_9;
            break;
         case 10:
            rBindingLevel = minion_bind_level_10;
            break;
         case 11:
            rBindingLevel = minion_bind_level_10;
            break;
      }

      if piChampionStatus <> 0
      {
         if piChampionStatus = CHAMPION_TOUGH
         {
            rChampionStatus = champion_tough_desc;
         }
         if piChampionStatus = CHAMPION_SWIFT
         {
            rChampionStatus = champion_swift_desc;
         }
         if piChampionStatus = CHAMPION_DEADLY
         {
            rChampionStatus = champion_deadly_desc;
         }
         if piChampionStatus = CHAMPION_INDOMITABLE
         {
            rChampionStatus = champion_indomitable_desc;
         }
         if piChampionStatus = CHAMPION_LEGENDARY
         {
            rChampionStatus = champion_legendary_desc;
         }
      }
      else
      {
         rChampionStatus = champion_nothing;
      }

      if iHit_Percent > 80
      {
         if piBehavior & AI_NPC
         {
            AddPacket(4,vrCondition_healthy,
                      4,rBindingLevel, 4,rMobDef, 4,rMobName, 4,rMasterIndef, 4,rMasterName,
                      4,vrDesc, 4,monster_nothing, 4,rChampionStatus);
         }
         else
         {
            if IsClass(self,&Marauder)
            {
               AddPacket(4,vrCondition_healthy,
                         4,rBindingLevel, 4,rMobDef, 4,rMobName, 4,rMasterIndef, 4,rMasterName,
                         4,vrDesc, 4,monster_blank_level,
                         4,rChampionStatus);
            }

            if piChampionStatus = 0
            {
               AddPacket(4,vrCondition_healthy,
                         4,rBindingLevel, 4,rMobDef, 4,rMobName, 4,rMasterIndef, 4,rMasterName,
                         4,vrDesc, 4,monster_desc_level,
                         4,piLevel, 4,rChampionStatus);
            }
            else
            {
               AddPacket(4,vrCondition_healthy,
                         4,rBindingLevel, 4,rMobDef, 4,rMobName, 4,rMasterIndef, 4,rMasterName,
                         4,vrDesc, 4,monster_desc_level,
                         4,piLevel, 4,rChampionStatus, 4, Send(self,@GetName));
            }
         }

         return;
      }
      else if iHit_Percent > 60
      {
         rMonster_condition = vrCondition_good;
      }
      else if iHit_Percent > 40
      {
         rMonster_condition = vrCondition_fair;
      }
      else if iHit_Percent > 20
      {
         rMonster_condition = vrCondition_poor;
      }
      else
      {
         rMonster_condition = vrCondition_bad;
      }

      if piBehavior & AI_NPC
      {
         AddPacket(4,rMonster_Condition,
                      4,rBindingLevel, 4,rMobDef, 4,rMobName, 4,rMasterIndef, 4,rMasterName,
                      4,vrDesc, 4,monster_nothing,
                      4,Send(self,@GetCapDef), 4,Send(self,@GetName), 4,rChampionStatus);
      }
      else
      {
         if IsClass(self,&Marauder)
         {
            AddPacket(4,vrCondition_healthy,
                      4,rBindingLevel, 4,rMobDef, 4,rMobName, 4,rMasterIndef, 4,rMasterName,
                      4,vrDesc, 4,monster_blank_level,
                      4,rChampionStatus);
         }

         if piChampionStatus = 0
         {
            AddPacket(4,rMonster_Condition,
                      4,rBindingLevel, 4,rMobDef, 4,rMobName, 4,rMasterIndef, 4,rMasterName,
                      4,vrDesc, 4,monster_desc_level,
                      4,piLevel, 4,Send(self,@GetCapDef),
                      4,Send(self,@GetName), 4,rChampionStatus);
         }
         else
         {
            AddPacket(4,rMonster_Condition,
                      4,rBindingLevel, 4,rMobDef, 4,rMobName, 4,rMasterIndef, 4,rMasterName,
                      4,vrDesc, 4,monster_desc_level,
                      4,piLevel, 4,Send(self,@GetCapDef),
                      4,Send(self,@GetName), 4,rChampionStatus, 4,Send(Self,@GetName));
         }
      }

      return;
   }

   GetMaxHitPoints()
   "Right now this returns the level. It is used to create the hp at "
   "construction, and to heal the monster, as well as for indicating "
   "its current damage."
   {
      local iMultiplier;

      iMultiplier = 1;
      if piChampionStatus = CHAMPION_TOUGH
         OR piChampionStatus = CHAMPION_INDOMITABLE
      {
         iMultiplier = 3;
      }
      
      if piChampionStatus = CHAMPION_LEGENDARY
      {
         iMultiplier = 10;
      }

      if piLevel < 40
      {
         return piLevel * iMultiplier;
      }

      return ((120 * piLevel) / 100) * iMultiplier;
   }
   
   ReturnMaxHitPoints()
   {
      return piMax_hit_points;
   }

   GainMaxHealth(amount = 0)
   "Equivalent to the message in Player, but without starting a timer."
   {
      local iPrev_max;

      iPrev_max = piMax_hit_points;
      piMax_hit_points = Bound(piMax_hit_points + amount, 1, $);

      return piMax_hit_points - iPrev_max;
   }

   GetMaxHealth()
   "Some objects will call this instead of the monster-specific message."
   {
      return piMax_hit_points;
   }

   SetMaxHitPoints(amount=$)
   {
      piMax_hit_points = amount;
      piHit_points = amount*100;

      return;
   }

   SetHealth(amount=0)
   {
      piHit_points = amount;
      return;
   }

   % Returns the number of remaining hit points.
   GetHealth()
   {
      return piHit_points/100;
   }

   GetExactHealth()
   {
      return piHit_points;
   }

   IsFullTalk()
   {
      % We AND with TRUE to have it return a boolean.
      return (viAttributes & MOB_FULL_TALK) AND TRUE;
   }

   GetBaseLevel()
   {
      return viLevel;
   }

   GetLevel()
   {
      return piLevel;
   }

   GetDifficulty()
   {
      return viDifficulty;
   }

   ClearBehavior(timer = $)
   {
      if ptBehavior <> timer AND ptBehavior <> $
      {
         DeleteTimer(ptBehavior);
      }

      ptBehavior = $;

      return;
   }

   IsObjectWeapon(what=$)
   {
      return Send(what,@IsItemType,#type=ITEMTYPE_WEAPON);
   }

   IsObjectSundry(what=$)
   {
      % perhaps here so certain merchants will buy them?
      if IsClass(what,&Torch)
      {
         return TRUE;
      }

      return Send(what,@IsItemType,#type=ITEMTYPE_SUNDRY);
   }

   IsObjectPotion(what=$)
   {
      return Send(what,@IsItemType,#type=ITEMTYPE_POTION);
   }

   IsObjectMisc(what=$)
   {
      % not sure why these were in misc but keeping them here for now
      if IsClass(what,&SpellItem)
         OR IsClass(what,&Arsenic)
      {
         return TRUE;
      }

      return Send(what,@IsItemType,#type=ITEMTYPE_MISC);
   }

   IsObjectWearable(what=$)
   {
      return Send(what,@IsItemType,#type=ITEMTYPE_RING) |
               Send(what,@IsItemType,#type=ITEMTYPE_NECKLACE) |
               Send(what,@IsItemType,#type=ITEMTYPE_ARMOR);
   }

   IsObjectGem(what=$)
   {
      if IsClass(what,&JewelofFroz)
      {
         return TRUE;
      }

      return Send(what,@IsItemType,#type=ITEMTYPE_GEM);
   }

   IsObjectReagent(what=$)
   {
      return Send(what,@IsItemType,#type=ITEMTYPE_REAGENT);
   }

   KarmaSame(who=$)
   "Return TRUE if the mob and the who have karmas of the same polarity."
   {
      local iPlayer_karma;

      % This means the monster has no Karma.
      if viKarma = $
      {
         return TRUE;
      }

      iPlayer_karma = Send(who,@GetKarma);
      
      % Second clause is to give newbies a break
      if (viKarma * Send(who,@GetKarma)) < 0
         AND abs(iPlayer_karma) >= 10
      {
         return FALSE;
      }

      return TRUE;
      
   }

   StartBasicTimers()
   {
      local oRoom;

      if IsClass(self,&Revenant)
      {
         return;
      }

      if (viAttributes & MOB_RANDOM)
      {
         ptRandom = CreateTimer(self,@RandomTimer,
                                viRandom_delay+Random(0,viRandom_delay/2));
      }

      if (viAttributes & MOB_SPASM)
      {
         ptSpasm = CreateTimer(self,@SpasmMonsterTimer,
                               viSpasm_delay+Random(0,viSpasm_delay/3));
      }

      return;
   }

   Fuzzy(num = 0, scale = 4)
   "Returns a number which is +/- num/scale of the original num."
   "Without the scale factor given, default is 0.75 to 1.25 of orig num."
   {
      if scale < 1
      {
         scale = 1;
      }

      if num < 0
      {
         num = num * -1;
         return (num - num/scale + Random(0,num*2/scale)) * -1; 
      }

      return num - num/scale + Random(0,num*2/scale);
   }

   ClearBasicTimers()
   {
      if ptRandom <> $
      {
         DeleteTimer(ptRandom);
         ptRandom = $;
      }

      if ptSpasm <> $
      {
         DeleteTimer(ptSpasm);
         ptSpasm = $;
      }

      if ptCancelOffer <> $
      {
         DeleteTimer(ptCancelOffer);
         ptCancelOffer = $;
      }

      poCustomer = $;

      % Clear spam list when last user leaves.
      plSpamList = $;

      return;
   }

   SetState(bit=0)
   "For now, the personality (or state) bits are used as numerical"
   "tokens rather than as independent flags."
   {
      % ESTATE gets erased when we change states
      if not(piState & bit)  
      {
         piState = piState & ESTATE_ZERO_MASK;
      }

      piState = piState & STATE_ZERO_MASK;
      piState = piState | bit;

      return;
   }

   GetAttackTime()
   {
      local i, iWait;

      iWait = Bound(Send(self,@Fuzzy,#num=MOB_ATTACK_TIMER_WAIT) + 3500-70*(3*viDifficulty+Send(self,@GetAttackSpeedWithOwnerBonuses)),250,$);

      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
      {
         iWait = Send(Nth(i,2),@ModifyDelay,#state=Nth(i,3),#iDelay=iWait);
      }
      return iWait;
   }
   
   GetAttackSpeedWithOwnerBonuses()
   {
      local iAttackSpeedMultiplier, oGear;
      
      iAttackSpeedMultiplier = 100;
      if poOwner <> $
         AND IsClass(poOwner,&Player)
      {
         foreach oGear in Send(poOwner,@GetPlayerUsing)
         {
            iAttackSpeedMultiplier = iAttackSpeedMultiplier + Send(oGear,@GetMinionAttackSpeedMultiplier);
         }
      }
      return (piAttackSpeed * iAttackSpeedMultiplier)/100;
   }

   GetMoveTime()
   {
      local iTime;

      % Unit of viSpeed is: #gridsquares per 10 seconds (per 10000 ms)
      % viSpeed is pre-defined by monster
      % Move-increment is predefined/fixed at 16fine unit per step
      % --> The elapse-interval is fixed!
  
      % EXAMPLE: SPEED_VERY_SLOW: 4 squares per 10000 ms
      % 1024 super-fine squares = 1 square
      % 256 super-fine squares = 1 highres square = 16 finesquare = stepwidth
      % -------------------------------------------------------
      % 4 * 1024 	= 4096 super-fine squares per 10000 ms
      % 4096 / 256  = 16 (Monster has to make 16 steps per 10000ms)
      % 10000 / 16  = 625 (steps must be made in 625ms intervals)
      % T = 10000 / ((viSpeed * 1024) / 256)  

      % avoid division by zero, if objects teleport
      % objects with viSpeed = 0 don't need seamless movements in the client
      % so we just assume it is enough to teleport them once a second
      if piMoveSpeed > 0
      {
         % see formula above  
         iTime = 10000 / (piMoveSpeed * 4);

         % finally we reduce the timer a bit (right now it's exact at ms)
         % why? the client should get a new position before the last destination
         % is reached. This prevents cases of stuttering if our message was a 
         % bit late in transmission. the client has a dynamic playout which 
         % will compensate this.
         iTime = iTime - 5;
		 
		 % make sure timer interval does not get negative
         % and also not like "run all the time"
         iTime = bound(iTime, 10, 10000);
      }
      else
      {
         iTime = 1000;
      }

      return iTime;
   }

   CutWantedItem(class = $)
   {
      local i;

      if class = $
      {
         return;
      }

      foreach i in plWantedItems
      {
         if i = class
         {
            % You only want to delete one of the items that the NPC wants so
            %  as not to ruin any quests for duplicate items
            %  (esp signet rings).
            plWantedItems = DelListElem(plWantedItems,i);

            return;   
         }
      }

      return;
   }

   SetWantedItem(class = $)
   {
      if class = $
      {
       return;
      }

      plWantedItems = cons(class,plWantedItems);

      return;
   }

   DeleteForSaleList()
   {
      local i;
      
      if plFor_sale = $
      {
         return;
      }

      foreach i in Nth(plFor_sale,2)
      {
         i = $;
      }

      foreach i in Nth(plFor_sale,3)
      {
         i = $;
      }

      foreach i in First(plFor_sale)
      {
         Send(i,@Delete);
      }

      if Length(plFor_sale) = 4
      {
         foreach i in Nth(plFor_sale,4)
         {
            Send(i,@Delete);
         }
      }

      plFor_sale = $;

      return;
   }

   CanAddSkill(who = $, num = 0)
   {
      local rval;

      rval = Send(who,@PlayerCanLearn,#skill_num=num,#spell_num=0);
      if rval = PLAYER_LEARN_SUCCESS
      {
         return TRUE;
      }

      return FALSE;
   }

   CanAddSpell(who = $, num = 0)
   {
      local rval;

      rval = Send(who,@PlayerCanLearn,#skill_num=0,#spell_num=num);
      if rval = PLAYER_LEARN_SUCCESS
      {
         return TRUE;
      }

      return FALSE;
   }

   HasDoneLearnQuest(who=$)
   {
      local iQuestHistory;

      if who = $
      {
         Debug("Who shouldn't be $!");

         return FALSE;
      }

      if viQuestID = 0
      {
         return TRUE;
      }

      iQuestHistory = First(Send(who,@GetQuestHistory,#index=viQuestID));
      return (QUEST_HISTORY_SUCCESS & iQuestHistory);
   }

   CanDoTeach(who = $, sid = 0, bSkill = FALSE)
   {
      local oAbility, iVal, iReason, iAmount, rAmount, bitSchools, i, tmp,
            lSchools;

      if sid = 0 OR who = $
      { 
         Debug("Invalid data sent to CanDoTeach!");  

         return FALSE; 
      }

      if bSkill
      {
         oAbility = Send(SYS,@FindSkillByNum,#num=sid);
      }
      else
      {
         oAbility = Send(SYS,@FindSpellByNum,#num=sid);
      }

      if oAbility = $
      {
         Debug("Got invalid sid info!",sid);

         return FALSE;
      }

      % Sacred Haven check.
      if NOT Send(oAbility,@IsAccessible)
      {
         return FALSE;
      }

%      if (NOT bSkill) AND IsClass(self,&Temples)
%         AND Send(oAbility,@GetLevel) > 2
%         AND NOT Send(self,@HasDoneLearnQuest,#who=who)
%      {
%         % Player needs to do a quest for the priestess to gain this spell or
%         %  skill.
%         
%         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
%              #string=vrTeach_quest_needed,#parm1=Send(oAbility,@GetName));
%
%         return FALSE;
%      }

      % KLUDGE: This should be handled in the individual subclasses.
      %         This makes baby Jesus cry.
%      if (IsClass(self,&JasperBlacksmith) OR IsClass(self,&JasperElder)
%          OR IsClass(self,&BarloqueApothecary) OR IsClass(self,&Minstrel))
%         AND NOT Send(self,@HasDoneLearnQuest,#who=who)
%      {
%         % Player needs to do a quest for the seller to gain this spell or
%         %  skill.
%         
%         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
%              #string=vrTeach_quest_needed,#parm1=Send(oAbility,@GetName));
%
%         return FALSE;
%      }

      if bSkill
      {
         iVal = Send(who,@PlayerCanLearn,#skill_num=SID);
      }
      else
      {
         iVal = Send(who,@PlayerCanLearn,#spell_num=SID);
      }

      if iVal = PLAYER_LEARN_ERROR
      {
         return FALSE;
      }

      if iVal = PLAYER_LEARN_HAS_VENTDAL
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=player_has_ventdal);

         return FALSE;
      }

      if iVal = PLAYER_LEARN_HAS_XAERDUN
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=player_has_xaerdun);

         return FALSE;
      }

      if iVal = PLAYER_LEARN_HAS_IWODACH
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=player_has_iwodach);

         return FALSE;
      }

      if iVal = PLAYER_LEARN_HAS_NEQUZON
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=player_has_nequzon);

         return FALSE;
      }

      if iVal = PLAYER_LEARN_SUCCESS
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_success,#parm1=Send(oAbility,@GetName));

         return TRUE;
      }

      if iVal = PLAYER_LEARN_ALREADY
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_already,#parm1=Send(oAbility,@GetName));

         return FALSE;
      }

      if iVal = PLAYER_LEARN_NOBASE
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_nobase,#parm1=Send(oAbility,@GetName));

         return FALSE;
      }

      if iVal = PLAYER_LEARN_KARMA 
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_karma,#parm1=Send(oAbility,@GetName));

         return FALSE;
      }

      if iVal = PLAYER_LEARN_IMPOSSIBLE 
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_impossible);

         return FALSE;
      }

      % Of we're below here, then the 1's column stores the reason, and the
      %  10s and 100s stores by how much.
      
      iReason = iVal mod 10;
      iAmount = iVal/10;     
      rAmount = Send(self,@LearnHowMuchFurther,#iAmount = iAmount);
      
      if iReason = PLAYER_LEARN_BASE
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_base,#parm1=rAmount,
              #parm2=Send(oAbility,@GetSchoolStr),
              #parm3=Send(oAbility,@GetName));

         return FALSE;
      }
      
      lSchools = $;              

      Debug("Oops, fell through in our testing for learning.");

      return FALSE;
   }

   LearnHowMuchFurther(iAmount=0,rval=0)
   {
      local temp_rsc;

      if iAmount < MONSTER_LEARN_GRADIENT
      {
         temp_rsc=monster_little;
      }
      else
      {
         if iAmount < 2 * MONSTER_LEARN_GRADIENT
         {
            temp_rsc=monster_nothing;
         }
         else
         {
            if iAmount < 3 * MONSTER_LEARN_GRADIENT
            {
               temp_rsc=monster_some;
            }
            else
            {
               if iAmount < 4 * MONSTER_LEARN_GRADIENT
               {
                  temp_rsc=monster_much;
               }
               else
               {
                  if iAmount < 5 * MONSTER_LEARN_GRADIENT
                  {
                     temp_rsc=monster_significantly;
                  }
                  else
                  {
                     temp_rsc=monster_drastically;
                  }
               }
            }
         }
      }

      return temp_rsc;
   }

   HasAttribute(mask = $)
   {
      return (viAttributes & mask);
   }

   % We AND to TRUE for the MobIs... functions to return a boolean instead
   %  of a value.
   MobIsBanker()
   {
      % We AND with TRUE to have it return a boolean.
      return ((viAttributes & MOB_BANKER) AND TRUE);
   }

   MobIsVaultman()
   {
      % We AND with TRUE to have it return a boolean.
      return ((viAttributes & MOB_VAULTMAN) AND TRUE);
   }

   MobIsBuyer()
   {
      % We AND with TRUE to have it return a boolean.
      return ((viAttributes & MOB_BUYER) AND TRUE);
   }

   MobIsCondSeller()
   {
      % We AND with TRUE to have it return a boolean.
      return ((viAttributes & MOB_COND_SELLER) AND TRUE);
   }

   MobIsPermQuester()
   {
      % We AND with TRUE to have it return a boolean.
      return ((viAttributes & MOB_PERM_QUESTER) AND TRUE);
   }

   MobIsSeller()
   {
      return (viAttributes & MOB_SELLER)
             OR (viAttributes & MOB_COND_SELLER)
             OR (viAttributes & MOB_TEACHER);
   }

   GetAttributes()
   {
      return viAttributes;
   }

   ObjectDesired(what=$)
   "This is set in individual buyers.  It allows them to pick and choose"
   "what they want to buy."
   {
      return TRUE;
   }

   InitCondSale()
   {
      return;
   }

   InitPermQuest()
   {
      return;
   }

   AddToConditionalList(obj=$,value=0)
   {
      local i;

      if plFor_sale = $ OR Length(plFor_sale) < 4
      {
         return;
      }

      foreach i in Nth(plFor_sale,4)
      {
         if First(i) = obj
         {
            return;
         }
      } 

      SetNth(plFor_sale,4,Cons([obj,value],Nth(plFor_sale,4)));

      return;
   }

   GetObjectOnConditionalList(class=$)
   {
      local i;

      if plFor_sale=$ OR Length(plFor_sale) < 4
      {
         return;
      }

      foreach i in Nth(plFor_sale,4)
      {
         if GetClass(First(i)) = class
         {
            return First(i);
         }
      } 

      return $;
   }

   RemoveFromConditionalList(obj=$)
   {
      local i;

      if obj = $ OR plFor_sale = $ OR Length(plFor_sale) < 4
      {
         return;
      }

      foreach i in Nth(plFor_sale,4)
      {
         if First(i)=obj
         {
            SetNth(plFor_sale,4,DelListElem(Nth(plFor_sale,4),i)); 

            return;
         }
      }

      return;
   }

   SetForSale()
   "Clears and recreates plFor_sale."
   {
      plFor_sale = $;

      return;
   }

   SetForSaleFrenzy(override=FALSE)
   "Used to give Innkeepers a frenzy sale list."
   {
      if Send(SYS,@GetChaosNight)
         OR override
      {
         plFor_sale = [
            [
               Create(&ShockRing),
               Create(&FireRing),
               Create(&ColdRing),
               Create(&AcidRing),
               Create(&BerserkerRing),
               Create(&RingInvisibility),
               Create(&LeatherArmor),
               Create(&ChainArmor),
               Create(&ScaleArmor),
               Create(&NeruditeArmor),
               Create(&PlateArmor),
               Create(&DiscipleRobe),
               Create(&GuildShield),
               Create(&NeruditeSword),
               Create(&Mace),
               Create(&Hammer),
               Create(&Axe),
               Create(&MysticSword),
               Create(&Scimitar),
               Create(&Longsword),
               Create(&Longbow),
               Create(&BattleBow),
               Create(&HealWand),
               Create(&Gauntlet),
               Create(&JewelOfFroz),
               Create(&Arrow,#number=150),
               Create(&SilverArrow,#number=150),
               Create(&NeruditeArrow,#number=150),
               Create(&IceArrow,#number=150),
               Create(&FireArrow,#number=150),
               Create(&Helm),
               Create(&Mint,#number=100),
               Create(&NeruditeBow),
               Create(&Gift),
               Create(&Chaosfood,#number=100),
               Create(&KarmaPotion,#karma=-10000),
               Create(&KarmaPotion,#karma=10000)
            ],
            $,
            $,
         $];
      }

      return;
   }

   AssembleVaultList(who=$)
   {
      local oVault, i, j;

      oVault = Send(SYS,@FindVaultByNum,#num=Send(self,@GetVaultNum));

      if oVault = $
      {
         Debug("Something wrong here!");

         return $;
      }

      return Send(oVault,@GetItemsStored,#who=who);      
   }

   GetCostPer100Bulk()
   {
      return 200;
   }

   GetForSale(who = $)
   "Returns the list of objects the mob has for sale "
   "(items, skills, spells, conditionals)"
   {
      local i,lForSale;

      if Send(self,@MobIsVaultman) 
      {
         return Send(self,@AssembleVaultList,#who=who);
      }
    
      if plFor_sale = $
      {
         return;
      }

      lForSale = $;

      % first do conditional items
      if Length(plFor_sale) = 4
      {
         foreach i in Nth(plFor_sale,4)
         {
            lForSale = cons(First(i),lForSale);
         }
      }

      % now do spells
      foreach i in Nth(plFor_sale,3)
      {
         if Send(self,@CanAddSpell,#who=who,#num=i)
            AND (Send(who,@GetSpellAbility,#spell_num=i) = 0)
         {
            lForSale = cons(Send(SYS,@FindSpellByNum,#num=i),lForSale);
         }
      }

      % now do skills
      foreach i in Nth(plFor_sale,2)
      {
         if Send(self,@CanAddSkill,#who=who,#num=i)
            AND (Send(who,@GetSkillAbility,#skill_num=i) = 0)
         {
            lForSale = cons(Send(SYS,@FindSkillByNum,#num=i),lForSale);
         }
      }

      % now do the items
      foreach i in First(plFor_sale)
      {
         lForSale = cons(i,lForSale);
      }

      if lForSale=$ 
      {
         Send(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
               #string=vrNothing_for_sale);
      }  

      return lForSale;
   }
   
   GetPrice(what = $, who = $)
   "Returns the value of an item, or the cost of a skill or spell"
   "No markup for skills or spells"
   {
      local i, x, y;

      if plFor_sale <> $ AND Length(plFor_sale) = 4
      {
         foreach i in Nth(plFor_sale,4)
         {
            if what=First(i)
            {
               return Nth(i,2);
            }
         }
      }

      if IsClass(what,&Item) 
      {
         x = Send(what,@GetInitValue) * (100 + 20*viMerchant_markup) / 100;
         y = Send(Send(SYS,@GetParliament),@GetFactionPriceBonus,#who=who,
                  #buying=TRUE);
         return Bound(x*y/100, 1, $);
      }

      if IsClass(what,&Spell) OR IsClass(what,&Skill)
      {
         return Send(what,@GetValue);
      }

      Debug("Strange item",what,":",Send(what,@GetName),"in GetPrice");

      return 0;
   }

   GetGender()
   {
      return viGender;
   }

   GetKarma(detect=FALSE)
   {
      if pbDontDispose
         AND NOT detect
      {
         % This means that the monster has no Karma.  This is used for event
         %  monsters like Xeos and admin-created beasties.
         return 0;
      }
      
      % A survival mob
      if poOwner <> $
         AND (IsClass(poOwner,&SurvivalRoom)
            OR IsClass(poOwner,&ChaosStratumRoom))
      {
         return 0;
      }
      
      return viKarma;
   }

   GetTreasureType()
   {
      return viTreasure_type;
   }

   CreateTreasure(who=$,corpse=$,ladderID=0)
   {
      local i, j, oReagent, iNumberItems, oTreasure, oTreasure_type,
            lTreasureItems, iNumberOfItemsDropped, iNumberOfItemsLooted,
            iRandomCashAmount, oMoney, iGetResult, bCapacityFailure,
            bRangeFailure, iSurvivalLoot, iNumShards, oShard, iRand,
            oBestiaryBook;

      % Apparitions, etc, provide no treasure
      if pbIllusion
         OR vbSummoned
      {
         return;
      }

      oTreasure_type = Send(SYS,@FindTreasureByNum,
                              #num=Send(self,@GetTreasureType));
      if oTreasure_type = $
      {
         Debug("Can't find monster treasure type",Send(self,@GetTreasureType),
               vrname,self);

         return;
      }

      % TreasureType now handles putting together the treasure list.
      % Returns a list of items to drop, or $.
      lTreasureItems = Send(oTreasure_Type,@CreateMobTreasure,#mob=self,
                              #who=who,#level=piLevel,#difficulty=viDifficulty,
                              #corpse=corpse,#attributes=viAttributes,
                              #boostedlevel=piBoostedLevel,
                              #iChaosLevel=piChaosLevel,
                              #ladderID=ladderID);

      % Add in our inventory
      foreach i in plActive
      {
         lTreasureItems = Cons(i,lTreasureItems);
      }

      foreach i in plPassive
      {
         lTreasureItems = Cons(i,lTreasureItems);
      }

      % Add money to the treasure
      iRandomCashAmount = Random(viCashMin,viCashMax);
      if iRandomCashAmount > 0
      {
         % Don't send a corpse unless the player killed the mob. Minion kills
         % already handed to the player in KilledSomething and double-checked
         % in Killed. Corpse is used for the loot timer, which GenerateTreasure
         % handles for monster kills but Constructor in Item does not.
         if NOT IsClass(who,&Player)
         {
            corpse = $;
         }

         oMoney = Create(&Money,#corpse=corpse,#number=(iRandomCashAmount + (piBoostedLevel
                     * Send(Send(SYS,@GetSurvivalRoomMaintenance),@GetSurvivalCash)) + (piChaosLevel
                     * Send(Send(SYS,@GetChaosStrataMaintenance),@GetChaosCash)))
                     * Send(self,@GetChampionRewardMultiplier),#ladderID=ladderID);

         Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=Send(oMoney,@GetNumber));
         lTreasureItems = Cons(oMoney,lTreasureItems);
      }

      % Add shards to champion treasure
      if Send(self,@GetChampStatus) > 0
      {
         iNumShards = Send(self,@GetChampionRewardMultiplier);
         if poOwner <> $
         {
            foreach i in Send(poOwner,@GetObjectAttributes)
            {
               if IsClass(i,&RoomThreat)
               {
                  iNumShards = Send(i,@AlterShardDrops,#iNumShards=iNumShards);
               }
            }
         }
         if Send(self,@GetLevel) < 50
         {
            --iNumShards;
         }
         if Send(self,@GetLevel) < 100
         {
            --iNumShards;
         }
         if Send(self,@GetLevel) < 150
         {
            --iNumShards;
         }
         while iNumShards > 0
         {
            iRand = Random(1,Send(SETTINGS_OBJECT,@GetEmpowerShardProbability)/100);
            if iRand = 1
            {
               oShard = Create(&ShardEmpowerment,#ladderID=ladderID);
            }
            else
            {
               iRand = Random(1,Send(SETTINGS_OBJECT,@GetMajorShardProbability)/100);
               if iRand = 1
               {
                  oShard = Create(&ShardImbueMajor,#ladderID=ladderID);
               }
               else
               {
                  iRand = Random(1,Send(SETTINGS_OBJECT,@GetDrainShardProbability)/100);
                  if iRand = 1
                  {
                     oShard = Create(&ShardRemove,#ladderID=ladderID);
                  }
                  else
                  {
                     iRand = Random(1,Send(SETTINGS_OBJECT,@GetAugmentShardProbability)/100);
                     if iRand = 1
                     {
                        oShard = Create(&ShardAugment,#ladderID=ladderID);
                     }
                     else
                     {
                        if IsClass(poOwner,&DesertRoom)
                           OR IsClass(poOwner,&MinotaurMazeRoom)
                           OR IsClass(poOwner,&AncientTomb1)
                        {
                           iRand = Random(1,Send(SETTINGS_OBJECT,@GetInstillingShardProbability)/10);
                           if iRand = 1
                           {
                              oShard = Create(&ShardReroll,#ladderID=ladderID);
                           }
                           else
                           {
                              iRand = Random(1,Send(SETTINGS_OBJECT,@GetImprovementShardProbability)/10);
                              if iRand = 1
                              {
                                 oShard = Create(&ShardImprovement,#ladderID=ladderID);
                              }
                              else
                              {
                                 iRand = Random(1,Send(SETTINGS_OBJECT,@GetDisruptionShardProbability)/10);
                                 if iRand = 1
                                 {
                                    oShard = Create(&ShardReImbueMajor,#ladderID=ladderID);
                                 }
                                 else
                                 {
                                    oShard = Create(&ShardReImbueMinor,#ladderID=ladderID);
                                 }
                              }
                           }
                        }
                        else
                        {
                           oShard = Create(&ShardImbueMinor,#ladderID=ladderID);
                        }
                     }
                  }
               }
            }
            
            lTreasureItems = Cons(oShard,lTreasureItems);
            --iNumShards;
         }
         
         if Random(1,100) = 1
         {
            if Random(1,2) = 1
            {
               oBestiaryBook = Create(&BestiarySpellBook,#ladderID=ladderID);
            }
            else
            {
               oBestiaryBook = Create(&BestiarySkillBook,#ladderID=ladderID);
            }
            lTreasureItems = Cons(oBestiaryBook,lTreasureItems);
         }
      }

      % Add shards to chaos stratum treasure
      if piChaosLevel > 0
      {
         iNumShards = Random(-5,piChaosLevel/40);
         
         if poOwner <> $
            AND Send(poOwner,@IsBoss,#what=self)
         {
            iNumShards = 4 + piChaosLevel/40;
         }

         if Send(self,@GetLevel) < 50
         {
            --iNumShards;
         }
         if Send(self,@GetLevel) < 100
         {
            --iNumShards;
         }
         if Send(self,@GetLevel) < 150
         {
            --iNumShards;
         }
         while iNumShards > 0
         {
            iRand = Random(1,Send(SETTINGS_OBJECT,@GetEmpowerShardProbability)/100);
            if iRand = 1
            {
               oShard = Create(&ShardEmpowerment,#ladderID=ladderID);
            }
            else
            {
               iRand = Random(1,Send(SETTINGS_OBJECT,@GetMajorShardProbability)/100);
               if iRand = 1
               {
                  oShard = Create(&ShardImbueMajor,#ladderID=ladderID);
               }
               else
               {
                  iRand = Random(1,Send(SETTINGS_OBJECT,@GetDrainShardProbability)/100);
                  if iRand = 1
                  {
                     oShard = Create(&ShardRemove,#ladderID=ladderID);
                  }
                  else
                  {
                     iRand = Random(1,Send(SETTINGS_OBJECT,@GetAugmentShardProbability)/100);
                     if iRand = 1
                     {
                        oShard = Create(&ShardAugment,#ladderID=ladderID);
                     }
                     else
                     {
                        if IsClass(poOwner,&DesertRoom)
                           OR IsClass(poOwner,&MinotaurMazeRoom)
                           OR IsClass(poOwner,&AncientTomb1)
                        {
                           iRand = Random(1,Send(SETTINGS_OBJECT,@GetInstillingShardProbability)/10);
                           if iRand = 1
                           {
                              oShard = Create(&ShardReroll,#ladderID=ladderID);
                           }
                           else
                           {
                              iRand = Random(1,Send(SETTINGS_OBJECT,@GetImprovementShardProbability)/10);
                              if iRand = 1
                              {
                                 oShard = Create(&ShardImprovement,#ladderID=ladderID);
                              }
                              else
                              {
                                 iRand = Random(1,Send(SETTINGS_OBJECT,@GetDisruptionShardProbability)/10);
                                 if iRand = 1
                                 {
                                    oShard = Create(&ShardReImbueMajor,#ladderID=ladderID);
                                 }
                                 else
                                 {
                                    oShard = Create(&ShardReImbueMinor,#ladderID=ladderID);
                                 }
                              }
                           }
                        }
                        else
                        {
                           oShard = Create(&ShardImbueMinor,#ladderID=ladderID);
                        }
                     }
                  }
               }
            }
            
            lTreasureItems = Cons(oShard,lTreasureItems);
            --iNumShards;
         }
         
         if poOwner <> $
            AND Send(poOwner,@IsBoss,#what=self)
         {
            if piChaosLevel = 140
            {
               lTreasureItems = Cons(Create(&QorCharm,#ladderID=ladderID),lTreasureItems);
            }
            else if Random(1,100) <= Send(Send(SYS,@GetChaosStrataMaintenance),@GetBaseScryingCrystalDropChance) + Send(poOwner,@GetQuality)
            {
               lTreasureItems = Cons(Create(&ScryingCrystal,#iTier=Bound(Send(poOwner,@GetTier)+Random(-1,1),1,5),
                                                            #iChaosLevel=piChaosLevel+1,
                                                            #level=180+piChaosLevel,
                                                            #ladderID=ladderID),lTreasureItems);
      
               if Send(poOwner,@GetQuality) >= 100
                  AND Random(1,100) <= Send(poOwner,@GetQuality) - 100
               {
                  lTreasureItems = Cons(Create(&ScryingCrystal,#iTier=Bound(Send(poOwner,@GetTier)+Random(-1,1),1,5),
                                                               #iChaosLevel=piChaosLevel+1,
                                                               #level=180+piChaosLevel,
                                                               #ladderID=ladderID),lTreasureItems);
               }
            }
         }
      }

      iNumberOfItemsDropped = 0;
      iNumberOfItemsLooted = 0;
      bCapacityFailure = FALSE;
      bRangeFailure = FALSE;
      
      % Now drop all the treasure.
      foreach oTreasure in lTreasureItems
      {
         if Send(poOwner,@ReqNewHold,#what=oTreasure,#new_row=piRow,
                 #new_col=piCol)
         {
            Send(poOwner,@NewHold,#what=oTreasure,
                  #new_row=piRow,#new_col=piCol,
                  #fine_row=piFine_row,#fine_col=piFine_col);

            if NOT IsClass(oTreasure,&Money)
            {
               ++iNumberOfItemsDropped;
            }

            if IsClass(oTreasure,&NumberItem)
               AND Send(SYS,@UtilGetRoom,#what=oTreasure) = Send(who,@GetOwner)
               AND Send(oTreasure,@GetPos) <> $
               AND IsClass(who,&User)
               AND Send(who,@CheckPlayerPreference,#flag=CF_AUTOLOOT)
               AND (IsClass(oTreasure,&Money)
                       OR (NOT bRangeFailure
                           AND NOT bCapacityFailure))
            {
               iGetResult = Send(who,@UserGet,#what=oTreasure,#report=FALSE);
               if NOT IsClass(oTreasure,&Money)
                  AND (iGetResult = AUTOLOOT_GOT_ITEM
                         OR iGetResult = AUTOLOOT_GOT_PARTIAL_STACK)
               {
                  ++iNumberOfItemsLooted;
               }

               if iGetResult = AUTOLOOT_OUT_OF_RANGE
               {
                  bRangeFailure = TRUE;
               }
               else if (iGetResult = AUTOLOOT_GOT_PARTIAL_STACK
                        OR iGetResult = AUTOLOOT_CANNOT_GET)
               {
                  bCapacityFailure = TRUE;
               }
            }
         }
         else
         {
            Send(oTreasure,@Delete);
         }
      }

      % Handle autoloot resources displayed to user.
      if iNumberOfItemsDropped <> 0
         AND IsClass(who,&User)
         AND Send(who,@CheckPlayerPreference,#flag=CF_AUTOLOOT)
      {
         if bRangeFailure
         {
            Send(who,@MsgSendUser,#message_rsc=autoloot_too_far_away);

            return;
         }

         if bCapacityFailure
         {
            if iNumberOfItemsLooted > 0
            {
               Send(who,@MsgSendUser,#message_rsc=autoloot_got_some_but_full_now);
            }
            else if iNumberOfItemsLooted = 0
            {
               if iRandomCashAmount > 0
               {
                  Send(who,@MsgSendUser,#message_rsc=autoloot_got_only_shillings_because_full,
                        #parm1=Send(oMoney,@GetNumber));
               }
               else
               {
                  Send(who,@MsgSendUser,#message_rsc=autoloot_got_nothing_because_full);
               }
            }

            return;
         }

         if iNumberOfItemsLooted > 0
         {
            if iNumberOfItemsLooted = iNumberOfItemsDropped
            {
               if iRandomCashAmount > 0
               {
                  Send(who,@MsgSendUser,#message_rsc=autolooted_all,
                        #parm1=Send(oMoney,@GetNumber));
               }
               else
               {
                  Send(who,@MsgSendUser,#message_rsc=autolooted_all_no_money);
               }
            }
            else if iNumberOfItemsLooted < iNumberOfItemsDropped
            {
               if iRandomCashAmount > 0
               {
                  Send(who,@MsgSendUser,#message_rsc=autolooted_some,
                        #parm1=Send(oMoney,@GetNumber));
               }
               else
               {
                  Send(who,@MsgSendUser,#message_rsc=autolooted_some_no_money);
               }
            }
         }
         else if iNumberOfItemsLooted = 0
         {
            if iRandomCashAmount > 0
            {
               Send(who,@MsgSendUser,#message_rsc=autolooted_only_money,
                     #parm1=Send(oMoney,@GetNumber));
            }
            else if iRandomCashAmount <= 0
            {
               Send(who,@MsgSendUser,#message_rsc=autolooted_none);
            }
         }
      }

      return;
   }

   CanMonsterFight(who=$)
   {
      if (piBehavior & AI_NPC)
      {
         if who <> $
         {
            %Send(who,@MsgSendUser,#message_rsc=LS_nofight_attacked);
         }

         return FALSE;
      }

      return TRUE;
   }

   IsCustomerOkay(who=$)
   {
      % Do business with everyone.

      return TRUE;
   }

   SomeoneTryUserCommand(who = $,command = $,data = $)
   {
      if NOT (viAttributes & MOB_BANKER) AND NOT (viAttributes & MOB_VAULTMAN)
      {
         return;
      }

      if NOT Send(self,@IsCustomerOkay,#who=who)
      {
         propagate;
      }

      if command = UC_DEPOSIT
      {
         if (viAttributes & MOB_VAULTMAN)
         {
            return TRUE;
         }

         Send(self,@BankDeposit,#who=who,#amount=data);

         return TRUE;
      }

      if command = UC_WITHDRAW
      {
         if (viAttributes & MOB_VAULTMAN)
         {
            return TRUE;
         }

         Send(self,@BankWithdraw,#who=who,#amount=data);

         return TRUE;
      }

      if command = UC_BALANCE
      {
         Send(self,@BankBalance,#who=who);

         return TRUE;
      }

      propagate;
   }

   DestroyDisposable()
   {
      if (viAttributes & MOB_LISTEN)
         OR (piBehavior & AI_NPC)
         OR poMaster <> $
         OR pbDontDispose
      {
         return;
      }

      Send(self,@Delete);

      return;
   }

   SetDontDispose(bValue=TRUE)
   {
      pbDontDispose = bValue;

      return pbDontDispose;
   }

   GetObjectFlags(what=$)
   {
      local iFlags;

      iFlags = viObject_flags | piDrawEffectFlag;

      if (piBehavior & AI_NPC)
      {
         iFlags = iFlags & ~OF_ATTACKABLE;
      }

      if Send(Self,@MobIsSeller)
      {
         iFlags = iFlags | OF_BUYABLE;
      }

      if ((viAttributes & MOB_BUYER
         OR viAttributes & MOB_RECEIVE)
         OR what <> $ AND IsClass(what,&DM))
      {
         iFlags = iFlags | OF_OFFERABLE;
      }

      return iFlags;
   }

   Say(message_rsc=$, parm1=$, parm2=$, parm3=$, parm4=$,
       parm5=$, parm6=$, parm7=$, parm8=$)
   {
      Send(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
           #string=message_rsc,#parm1=parm1,#parm2=parm2,#parm3=parm3,
           #parm4=parm4,#parm5=parm5,#parm6=parm6,#parm7=parm7,#parm8=parm8);

      return;
   }

   SayToOne(target=$, message_rsc=$,
            parm1=$, parm2=$, parm3=$, parm4=$, parm5=$,
            type1=STANDARD_RESOURCE, type2=STANDARD_RESOURCE,
            type3=STANDARD_RESOURCE, type4=STANDARD_RESOURCE,
            type5=STANDARD_RESOURCE)
   {
      if target = $
      {
         Debug("SayToOne reached with null target.");
         return;
      }

      Send(target,@MsgSendUser,#message_rsc=monster_say_to_one,
           #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName),
           #parm3=message_rsc,#parm4=parm1,#type4=type1,
           #parm5=parm2,#type5=type2,#parm6=parm3,#type6=type3,
           #parm7=parm4,#type7=type4,#parm8=parm5,#type8=type5);

      return;
   }
   
   CanMorphTo()
   {
      return TRUE;
   }

   IsIllusion()
   {
      return pbIllusion;
   }

   % TRUE if mob can have evil twin cast on it
   CanEvilTwin()
   {
      return TRUE;
   }

   ApparitionCaster(who=$)
   "If this monster is an apparition, keep track of the caster."
   {
      poApparitionCaster = who;

      return;
   }

   IsOwnedByPlayer()
   "Checks the two cases of minions, and returns TRUE if owned by "
   "a player, FALSE if not. If minion has a monster for a master, "
   "IsOwnedByPlayer is called on the master."
   {
      if poMaster <> $
      {
         if IsClass(poMaster,&Player)
         {
            return TRUE;
         }

         if IsClass(poMaster,&Monster)
         {
            return Send(poMaster,@IsOwnedByPlayer);
         }

         % Could be a room or an item that owns the monster.
         % If we allow players to attach minions to guild halls
         % or other creative uses of non-player/monster owners,
         % we may need to change this.
         return FALSE;
      }

      if poApparitionCaster <> $
      {
         if IsClass(poApparitionCaster,&User)
         {
            return TRUE;
         }

         if IsClass(poApparitionCaster,&Monster)
         {
            return Send(poApparitionCaster,@IsOwnedByPlayer);
         }

         return FALSE;
      }

      return FALSE;
   }

   IsMinion()
   "Returns TRUE for seduced and animated mobs, reflections, "
   "evil twins and apparitions."
   {
      if poMaster <> $
         OR poApparitionCaster <> $
      {
         return TRUE;
      }

      return FALSE;
   }

   % This section deals with minion code.
   CommandMinionAttack(oMaster=$,oTarget=$)
   {
      local oActive;

      % If we have minions, we only want them to attack Battlers,
      % not items or anything else that can damage us.
      if plControlledMinions = $
         OR oTarget = $
         OR NOT IsClass(oTarget,&Battler)
         OR IsClass(oTarget,&Revenant)
      {
         return;
      }

      % Lets not have the minions kill each other. Check if the target is
      % a minion under our control.
      if IsClass(oTarget,&Monster)
         AND Send(oTarget,@GetMaster) = self
      {
         return;
      }

      foreach oActive in plControlledMinions
      {
         if IsClass(oActive,&Monster)
            AND Send(oActive,@GetMaster) = self
            AND Send(oActive,@GetTarget) <> oTarget
         {
            Send(oActive,@SetBehaviorFlag,
                  #flag=AI_MOVE_FOLLOW_MASTER,#value=FALSE);
            Send(oActive,@TargetSwitch,#what=oTarget,
                  #iHatred=100);
            Send(oActive,@EnterStateChase,#target=oTarget,
                  #actnow=TRUE);
         }
      }

      return;
   }

   CanPlayerAdvanceOnMe()
   {
      return (NOT Send(self,@IsIllusion));
   }

   SetIllusion(value = $)
   {
      if value = $
      {
         Debug("SetIllusion called without an argument!");
         value = FALSE;
      }

      pbIllusion = value;
      
      if value = TRUE
      {
         Send(self,@LoseChampionStatus);
      }

      return;
   }
   
   GetSummoned()
   {
      return vbSummoned;
   }

   SetSummoned(value = $)
   {
      if value = $
      {
         Debug("SetSummoned called without an argument!");
         value = FALSE;
      }

      vbSummoned = value;

      return;
   }

   DispelIllusionEnchantments(report = TRUE, iChance = 100)
   {
      local i, oSpell, each_obj;

      foreach i in plEnchantments 
      {                       
         oSpell = Nth(i,2);
         if Send(oSpell,@IsIllusion)
            AND Random(1,100) <= iChance
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      return;
   }

   RemoveSchoolEnchantments(school = $, report=TRUE)
   {
      local i, oSpell, each_obj;

      foreach i in plEnchantments 
      {                       
         oSpell = Nth(i,2);
         if Send(oSpell,@GetSchool) = school
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      return;
   }

   GetClosestFrightener()
   {
      local lActive, iRangeSquared, oTarget, iThisRangeSquared, i,
            iDistRow, iDistCol, oIllusion, oObject, oBodyType;

      if poOwner = $
      {
         return $;
      }

      iRangeSquared = piVisionDistance * piVisionDistance;

      oTarget = $;

      lActive = Send(poOwner,@GetHolderActive);
      foreach i in lActive
      {
         oObject = First(i);

         % Pass if we're looking at ourself here.
         if oObject = self
         {
            continue;
         }

         oBodyType = oObject;
         if IsClass(oObject,&User)
         {
            oIllusion = Send(oObject,@GetIllusionForm);
            if oIllusion <> $
            {
               oBodyType = oIllusion;
            }
         }

         % Check if we are scared of this.
         if NOT Send(self,@IsFrightenedOf,#target=oBodyType,#regroup=TRUE)
         {
            continue;
         }

         iDistRow = (piRow * FINENESS + piFine_row)
                     - (Send(oObject,@GetRow) * FINENESS + Send(oObject,@GetFineRow));

         iDistCol = (piCol * FINENESS + piFine_col)
                     - (Send(oObject,@GetCol) * FINENESS + Send(oObject,@GetFineCol));

         iThisRangeSquared = (iDistRow * iDistRow + iDistCol * iDistCol)
                                 / FINENESS_SQUARED;

         if iThisRangeSquared <= iRangeSquared
         {
            iRangeSquared = iThisRangeSquared;
            oTarget = oObject;
         }
      }

      % oTarget = nil if none are in range.
      return oTarget;
   }

   IsFrightenedOf(target = $)
   {
      if vbIsUndead
         AND (poHolySymbolCaster <> $)
         AND (poHolySymbolCaster = target)
      {
         return TRUE;
      }

      return FALSE;
   }

   GetClosestAlly()
   {
      local lActive, iRangeSquared, oTarget, iThisRangeSquared, i,
            iDistRow, iDistCol, oIllusion, oObject, oBodyType;

      if poOwner = $
      {
         return $;
      }

      oTarget = $;

      iRangeSquared = piVisionDistance * piVisionDistance;

      lActive = Send(poOwner,@GetHolderActive);
      foreach i in lActive
      {
         oObject = First(i);

         % Pass if we're looking at ourself here.
         if oObject = self
         {
            continue;
         }

         % is what it looks like, an ally?
         oBodyType = oObject;
         if IsClass(oObject,&User)
         {
            oIllusion = Send(oObject,@GetIllusionForm); 
            if oIllusion <> $
            {
               oBodyType = oIllusion;
            }
         }

         % If not an ally, we don't care.
         if NOT Send(self,@IsAlly,#target=oBodyType,#regroup=TRUE)
         {
            continue;
         }

         iDistRow = (piRow * FINENESS + piFine_row)
                     - (Send(oObject,@GetRow) * FINENESS + Send(oObject,@GetFineRow));

         iDistCol = (piCol * FINENESS + piFine_col)
                     - (Send(oObject,@GetCol) * FINENESS + Send(oObject,@GetFineCol));

         iThisRangeSquared = (iDistRow * iDistRow + iDistCol * iDistCol)
                              / FINENESS_SQUARED;

         if iThisRangeSquared <= iRangeSquared
         {
            iRangeSquared = iThisRangeSquared;
            oTarget = oObject;
         }
      }

      % oTarget = nil if none are in range.
      return oTarget;
   }

   IsAlly(target=$,regroup=FALSE)
   {
      if IsClass(target,GetClass(self))
         OR (poMaster <> $
            AND IsClass(target,&Battler)
            AND Send(target,@GetMaster) = poMaster)
      {
         return TRUE;
      }

      return FALSE;
   }

   HealthBelowWimpy()
   {
      % Wimpy of 0 means monster never runs, just fights til the end.
      if viWimpy = 0
      {
         return FALSE;
      }
      
      % If wimpy is set at 50, monster will flee once his health is at 49% of
      %  max.
      if (piHit_points/ piMax_Hit_points) < viWimpy
      {
         return TRUE;
      }

      return FALSE;
   }

   GetMaster()
   {
      return poMaster;
   }

   % Evil twin and reflection have an override for this.
   SetMaster(oMaster=$, bLoggingOn=FALSE)
   {
      if oMaster = $
      {
         if poMaster <> $
         {
            Send(poMaster,@RemoveControlledMinion,#what=self);
            
            if Send(self,@IsEnchanted,#byClass=&CreatureBinding)
            {
               Send(self,@RemoveEnchantment,#what=Send(SYS,@FindSpellByNum,#num=SID_CREATURE_BINDING));
            }

            % After the honeymoon is over, go after the master!
            Send(self,@SetBehaviorFlag,#flag=AI_MOVE_FOLLOW_MASTER,
                  #value=FALSE);
            Send(self,@TargetSwitch,#what=poMaster,#iHatred=150);
            poMaster = $;
            
            piMoveSpeed = piSavedMovedSpeed;

            Send(self,@EnterStateChase);
         }
      }
      else
      {
         poMaster = oMaster;

         % Break target.
         Send(self,@EnterStateWait);
         
         % Clear patrols.
         Send(self,@ClearPatrolLocation);
         
         % Do we boost speed?
         if NOT Send(self,@IsIllusion)
            AND IsClass(poMaster,&Player)
            AND Send(poMaster,@HasSkill,#num=SKID_MINION_SPEED_BOOST)
         {
            piSavedMovedSpeed = piMoveSpeed;
            piMoveSpeed = Send(Send(SYS,@FindSkillByNum,#num=SKID_MINION_SPEED_BOOST),@ModifyMinionSpeed,#who=poMaster,#iMoveSpeed=piMoveSpeed,#bLoggingOn=bLoggingOn);
         }

         % Uncomment this if post-capture attack behavior changes.
         %if NOT Send(SYS,@IsPKAllowed)
         %   AND (poTarget <> $
         %      AND IsClass(poTarget,&Player))
         %{
         %   % Forget our target
         %   Send(self,@EnterStateWait);
         %}
      }

      if poOwner <> $
      {
         Post(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetBehaviorFlag(flag=0, value = TRUE)
   {
      if value
      {
         piBehavior=piBehavior | flag ;
      }
      else
      {
         piBehavior=piBehavior & ~flag ;
      }

      return;
   }
   
   IsWizard()
   {
      return FALSE;
   }  
  
   GetHatred()
   {
      return piHatred;
   }

   TargetSwitch(what=$, iHatred = 0)
   {
      if what = $
         OR poOwner = $
      {
         % Suppress survival messages, because this happens sometimes there.
         if piBoostedLevel = 0
         {
            Debug("BAD target we're switching to here!");
            Debug(self);
         }
         
         if poOwner = $
         {
            Post(self,@Delete);
         }

         return;
      }

      if IsClass(what,&User)
         AND NOT Send(what,@IsLoggedOn)
      {
         % Trying to switch to someone logged off. Can't do that.
         return;
      }
      if IsClass(what,&Player)
            AND Send(what,@GetSkillAbility,#skill_num=SKID_HIDE) >= piLevel/2
            AND Send(Send(SYS,@FindSkillByNum,#num=SKID_HIDE),@IsHiding,#who=what)
      {
         % Trying to switch to a hidden player
         return;
      }

      piHatred = iHatred;

      if poTarget <> $
         AND Send(poTarget,@GetOwner) = poOwner
         AND IsClass(poTarget,&user)
      {
         Send(poTarget,@SubtractFromMonsterChasers,
              #level=piAmountAddedToMonsterChasers);
      }

      poTarget = what;
      if IsClass(poTarget,&user)
      {
         piAmountAddedToMonsterChasers = piLevel;
         Send(poTarget,@AddToMonsterChasers,#level=piAmountAddedToMonsterChasers);
      }

      piState = (piState & VSTATE_VALIDITY_MASK);

      % 'lock' sound
      if vrSound_aware <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=vrSound_aware);
      }

      return;
   }

   SpecialHatredBehavior(what=$)
   "A monster may hate an opponent more under special behaviors, or may "
   "hate certain opponents more.  Use this to check for those special cases."
   "Test case is avar clans fighting in the temple ruins."
   {
      return 0;
   }

   GetMood()
   {
      return piMood;
   }

   % used for library speech/random lib restriction vectors
   GetMoodFlags()
   {
      if piMood < -10
      {
         return LIBRES_MOOD_BAD;
      }

      if piMood > 10
      {
         return LIBRES_MOOD_GOOD;
      }

      return LIBRES_MOOD_NEUTRAL;
   }

   SetMood(new_mood = 0)
   {
      piMood = Bound(new_mood,-100,100);

      return;
   }

   ChangeMood(change = 0)
   {
      piMood = Bound(piMood+change,-100,100);

      return;
   }

   IsInvisible()
   {
      return (Send(self,@GetDrawingEffects) & DRAWFX_INVISIBLE);
   }

   IsShadowForm()
   {
      return (Send(self,@GetDrawingEffects) & DRAWFX_BLACK);
   }

   GetVaultNum()
   {
      return $;
   }

   GetBankNum()
   {
      return $;
   }

   GetIllusionForm()
   {
      return $;
   }

   PrintState()
   "Prints monster state out to the Debug log."
   {
      if (piState & STATE_LIMBO)
      {
         Debug(self,"is in limbo.");
      }

      if (piState & STATE_WAIT)
      {
         Debug(self,"is in wait");
      }

      if (piState & STATE_ATTACK)
      {
         Debug(self,"is in attack");
      }

      if (piState & STATE_CHASE)
      {
         Debug(self,"is in chase");
      }

      if (piState & STATE_MOVE)
      {
         Debug(self,"is in move");
      }

      if ptBehavior = $
      {
         Debug("Behavior Timer is equal to nil!");

         return;
      }

      Debug("ptBehavior has ",GetTimeRemaining(ptBehavior),"ms left.");

      return;
   }

   GetFaction()
   {
      return viFaction;
   }

   AddLearnAdvice()
   {
      local i, lFinal, lDialogue, oAbility, sid, oName;

      % Go through the monster's sell list.  If the monster has a spell or 
      %  skill to sell, add it to their dialogue.

      if NOT (viAttributes & MOB_TEACHER)
      {
         return;
      }

      if plFor_sale = $ OR Length(plFor_sale) < 3
      {
         return;
      }  

      lDialogue = $;

      foreach sid in nth(plFor_sale,2)
      {
         % skills first
         oAbility = Send(SYS,@FindSkillByNum,#num=sid);
         if oAbility <> $
         {
            oName = Send(oAbility,@GetName);
         }
         
         lDialogue = cons([[oName],0,[LIBACT_LEARN, sid, TRUE]],lDialogue);
      }
      
      foreach sid in nth(plFor_sale,3)
      {
         % spells next
         oAbility = Send(SYS,@FindSpellByNum,#num=sid);
         if oAbility <> $
         {
            oName = Send(oAbility,@GetName);
         }
         
         lDialogue = cons([[oName],0,[LIBACT_LEARN, sid, FALSE]],lDialogue);
      }
      
      lFinal = [ GetClass(self), lDialogue ];

      Send(Send(SYS,@GetLibrary),@AppendSpeechLibrary,#lDialogue=lFinal);
      
      return;
   }

   GetBrain()
   {
      return poBrain;
   }

   IsUndead()
   {
      return vbIsUndead;
   }

   TurnedBy(who = $)
   {
      if who = $
      {
         Debug("Turned by $.");

         return;
      }

      if NOT vbIsUndead
      {
         Debug("Somehow turned a monster that isn't undead.");

         return;
      }

      poHolySymbolCaster = who;

      if ptUnturn <> $
      {
         DeleteTimer(ptUnturn);
         ptUnturn = $;
      }

      ptUnturn = CreateTimer(self,@UnTurn,TURN_TIME/viDifficulty);
      
      return;
   }

   UnTurn()
   {
      ptUnturn = $;
      poHolySymbolCaster = $;

      return;
   }

   DMCanArmageddon()
   {
      return TRUE;
   }

   CanBeSilenced()
   "Can this monster be silenced by the room enchantment?"
   {
      return TRUE;
   }

   RewardSweep(who = $)
   {
      local oMoney,oRoom;

      oMoney=Create(&Money,#number=Random(20,120),#ladderID=Send(who,@GetLadderID));
      oRoom = Send(self,@GetOwner);

      if piSweepCounter < 5
      {
         Post(oRoom,@SomeoneSaid,#what=self,#string=Monster_Sweep_Reward,
              #type=SAY_RESOURCE,#parm1=Send(who,@GetDef),
              #parm2=Send(who,@GetName));
              
         piSweepCounter = piSweepCounter + 1;
         
         if Send(who,@ReqNewHold,#what=oMoney)
         {
            Send(who,@NewHold,#what=oMoney);
            Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=Send(oMoney,@GetNumber));
         }
         else
         {
            Send(oMoney,@Delete);
         }
      }
      
      return;
   }

   % Gets the projectile icon of the monster.  If monster doesn't use
   %  projectiles, return nil
   GetProjectileIcon()
   {
      return;
   }
   
   GetBaseResistances()
   {
      local i, lResistances;
      
      lResistances = ListCopy(plResistances);

      foreach i in plRadiusEnchantments
      {
         lResistances = Send(First(i),@ModifyResistances,#resistance_list=lResistances,#lRadiusState=i);
      }
      return lResistances;
   }
   
   GetBoostedLevel()
   {
      return piBoostedLevel;
   }
   
   GetChaosLevel()
   {
      return piChaosLevel;
   }

   % GainLight and LoseLight here so (some) mobs can use touch spells.
   GainLight()
   {
      return 0;
   }

   LoseLight()
   {
      return 0;
   }

   GetChampString()
   {
      if piChampionStatus = CHAMPION_TOUGH
      {
         return champion_tough_prefix;
      }
      
      if piChampionStatus = CHAMPION_SWIFT
      {
         return champion_speed_prefix;
      }
      
      if piChampionStatus = CHAMPION_DEADLY
      {
         return champion_damage_prefix;
      }
      
      if piChampionStatus = CHAMPION_INDOMITABLE
      {
         return champion_all_prefix;
      }
      
      if piChampionStatus = CHAMPION_LEGENDARY
      {
         return champion_super_prefix;
      }
      
      return champion_none;
   }
   
   GetChampStatus()
   {
      return piChampionStatus;
   }
   
   GainChampionStatus(iType=0, bJailed=FALSE)
   {
      local i, each_obj;

      if poOwner = $
         AND NOT bJailed
      {
         return;
      }

      piChampionStatus = iType;

      piMax_Hit_points = Send(Self,@Fuzzy,#num=Send(self,@GetMaxHitPoints))
                         + piBoostedLevel*viDifficulty
                         + piChaosLevel * Send(Send(SYS,@GetChaosStrataMaintenance),@GetChaosDifficulty);
      piHit_points = piMax_hit_points*100;
      
      if iType = CHAMPION_SWIFT
         OR iType = CHAMPION_INDOMITABLE
      {
         piMoveSpeed = viSpeed * 2;
         piAttackSpeed = viSpeed * 2;
      }
      
      if iType = CHAMPION_TOUGH
         OR iType = CHAMPION_SWIFT
         OR iType = CHAMPION_DEADLY
      {
         Send(self,@AddRandomChampionAbility);
      }
      
      if iType = CHAMPION_INDOMITABLE
      {
         Send(self,@AddRandomChampionAbility);
         Send(self,@AddRandomChampionAbility);

         if NOT bJailed
         {
            foreach i in Send(poOwner,@GetHolderActive)
            {
               each_obj = Send(poOwner,@HolderExtractObject,#data=i);
               if IsClass(each_obj,&Player)
               {
                  Send(each_obj,@MsgSendUser,#message_rsc=indomitable_arrived,
                                             #parm1=Send(self,@GetName));
               }
            }
         }
      }
      
      if iType = CHAMPION_LEGENDARY
      {
         piAttackSpeed = viSpeed * 3;
         piMoveSpeed = viSpeed * 3;
         
         Send(self,@AddRandomChampionAbility);
         Send(self,@AddRandomChampionAbility);
         Send(self,@AddRandomChampionAbility);

         if NOT bJailed
         {
            foreach i in Send(poOwner,@GetHolderActive)
            {
               each_obj = Send(poOwner,@HolderExtractObject,#data=i);
               if IsClass(each_obj,&Player)
               {
                  Send(each_obj,@MsgSendUser,#message_rsc=legendary_arrived,
                                             #parm1=Send(self,@GetName));
               }
            }
         }
      }

      if NOT bJailed
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   AddChampionAbility(ability=0,value=0)
   {
      plChampionAbilities = Cons([ability,value],
                                  plChampionAbilities);
      return;
   }

   AddRandomChampionAbility()
   {
      local lAbilities, iRandomAbility, iValue, lElements, i;
      
      lAbilities = [CHAMPION_ABIL_MAGIC_RESISTANCE,
                    CHAMPION_ABIL_WEAPON_RESISTANCE,
                    CHAMPION_ABIL_EAGLE_EYES,
                    CHAMPION_ABIL_FREE_ACTION,
                    CHAMPION_ABIL_ELEMENTAL_DAMAGE_TYPE,
                    CHAMPION_ABIL_PURGE,
                    CHAMPION_ABIL_DISARM];
                    
      iRandomAbility = Nth(lAbilities,Random(1,Length(lAbilities)));
      iValue = 0;
      
      if iRandomAbility = CHAMPION_ABIL_MAGIC_RESISTANCE
         OR iRandomAbility = CHAMPION_ABIL_WEAPON_RESISTANCE
         OR iRandomAbility = CHAMPION_ABIL_EAGLE_EYES
         OR iRandomAbility = CHAMPION_ABIL_FREE_ACTION
      {
         iValue = Random(20,50);
      }
      
      if iRandomAbility = CHAMPION_ABIL_ELEMENTAL_DAMAGE_TYPE
      {
         lElements = [ATCK_SPELL_FIRE,
                      ATCK_SPELL_COLD,
                      ATCK_SPELL_SHOCK,
                      ATCK_SPELL_ACID,
                      ATCK_SPELL_HOLY,
                      ATCK_SPELL_UNHOLY];
         iValue = Nth(lElements,Random(1,Length(lElements)));
      }
      
      if iRandomAbility = CHAMPION_ABIL_PURGE
      {
         iValue = Random(5,15);
      }
      
      if iRandomAbility = CHAMPION_ABIL_DISARM
      {
         iValue = Random(5,10);
      }

      foreach i in plChampionAbilities
      {
         if First(i) = iRandomAbility
         {
            SetNth(i,2,Nth(i,2) + iValue);
            return;
         }
      }

      plChampionAbilities = Cons([iRandomAbility,iValue],
                                  plChampionAbilities);

      return;
   }
   
   LoseChampionStatus()
   {
      piChampionStatus = 0;
      plChampionAbilities = $;

      piMax_Hit_points = Send(Self,@Fuzzy,#num=Send(self,@GetMaxHitPoints))
                         + piBoostedLevel*viDifficulty
                         + piChaosLevel * Send(Send(SYS,@GetChaosStrataMaintenance),@GetChaosDifficulty);
      piHit_points = piMax_hit_points*100;
      
      piAttackSpeed = viSpeed;
      piMoveSpeed = viSpeed;
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }
      
      return;
   }

   SendLightingInformation()
   {
      if piCastPower > 0
      {
         AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC));
         % cast power intensity
         AddPacket(1,piCastPower);
         AddPacket(2,LIGHT_DRED);
         
         % Can we slide up the color scale?
         return;
      }

      if piChampionStatus > 0
         AND poOwner <> $
         AND Send(poOwner,@LightingColorOverride)
      {
         AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC));
         % 50 out of 255 intensity of light
         if piChampionStatus = 4
         {
            AddPacket(1,75);
         }
         else if piChampionStatus = 5
         {
            AddPacket(1,125);
         }
         else
         {
            AddPacket(1,50);
         }
         % Override color
         AddPacket(2,Send(poOwner,@GetLightingColorOverride,#what=self));
         return;
      }

      % Petrified gives off no light
      if Send(self,@IsEnchanted,#byClass=&Petrified)
      {
         if Send(poOwner,@LightingColorOverride)
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,0, 2,Send(poOwner,@GetLightingColorOverride,#what=self));
         }
         else
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,0, 2,LIGHT_WHITE);
         }
         return;
      }
      % Hold gives off a purple glow
      if Send(self,@IsEnchanted,#byClass=&Hold)
      {
         if Send(poOwner,@LightingColorOverride)
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,100, 2,Send(poOwner,@GetLightingColorOverride,#what=self));
         }
         else
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,100, 2,LIGHT_BPURPLE);
         }
         return;
      }
      % Blind gives off a dim green glow
      if Send(self,@IsEnchanted,#byClass=&Blind)
      {
         if Send(poOwner,@LightingColorOverride)
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,50, 2,Send(poOwner,@GetLightingColorOverride,#what=self));
         }
         else
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,50, 2,LIGHT_BGREEN);
         }
         return;
      }
      % Dazzle is blazing white
      if Send(self,@IsEnchanted,#byClass=&Dazzle)
      {
         if Send(poOwner,@LightingColorOverride)
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,255, 2,Send(poOwner,@GetLightingColorOverride,#what=self));
         }
         else
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,255, 2,LIGHT_WHITE);
         }
         return;
      }

      if piChampionStatus = 1
      {
         AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC));
         % 50 out of 255 intensity of light
         AddPacket(1,50);
         % Blue 'shield' glow.
         AddPacket(2,LIGHT_BBLUE);
         return;
      }
      if piChampionStatus = 2
      {
         AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC));
         % 50 out of 255 intensity of light
         AddPacket(1,50);
         % Orange 'speedy' glow.
         AddPacket(2,LIGHT_BORANGE);
         return;
      }
      if piChampionStatus = 3
      {
         AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC));
         % 50 out of 255 intensity of light
         AddPacket(1,50);
         % Red 'danger' glow.
         AddPacket(2,LIGHT_BRED);
         return;
      }
      if piChampionStatus = 4
      {
         AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC));
         % 75 out of 255 intensity of light
         AddPacket(1,75);
         % Green 'everything' glow.
         AddPacket(2,LIGHT_BGREEN);
         return;
      }
      if piChampionStatus = 5
      {
         AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC));
         % 125 out of 255 intensity of light
         AddPacket(1,125);
         % Purple 'we're all gonna die' glow.
         AddPacket(2,LIGHT_BPURPLE);
         return;
      }
      
      if poOwner <> $
         AND IsClass(poOwner,&ChaosStratumRoom)
         AND NOT IsClass(poOwner,&OutdoorsF8)
      {
         AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC));
         AddPacket(1,50);
         AddPacket(2,LIGHT_BRED);
         return;
      }

      propagate;
   }
   
   GetLegendaryName()
   {
      return legendary_name_none;
   }
   
   GetBlindResistance()
   {
      local i;
      
      foreach i in plChampionAbilities
      {
         if First(i) = CHAMPION_ABIL_EAGLE_EYES
         {
            return Nth(i,2);
         }
      }
      
      return 0;
   }
   
   GetHoldResistance()
   {
      local i;
      
      foreach i in plChampionAbilities
      {
         if First(i) = CHAMPION_ABIL_FREE_ACTION
         {
            return Nth(i,2);
         }
      }
      
      return 0;
   }
   
   GetChampionRewardMultiplier()
   {
      local i;

      if piChampionStatus = CHAMPION_TOUGH
         OR piChampionStatus = CHAMPION_SWIFT
         OR piChampionStatus = CHAMPION_DEADLY
      {
         return TIER_ONE_CHAMPION_REWARD_MULTIPLIER;
      }

      if piChampionStatus = CHAMPION_INDOMITABLE
      {
         return TIER_TWO_CHAMPION_REWARD_MULTIPLIER;
      }

      if piChampionStatus = CHAMPION_LEGENDARY
      {
         return TIER_THREE_CHAMPION_REWARD_MULTIPLIER;
      }

      propagate;
   }

   GetTumbling()
   {
      return piTumbling;
   }

   GetBossStatus()
   {
      return FALSE;
   }

   DrawResistances()
   {
      return;
   }

   ApplyMaximumResistances(resistance_list=$)
   {
      % Monster resistances are not capped.
      return resistance_list;
   }

   DrawDefense()
   {
      return;
   }
   
   DrawOffense()
   {
      return;
   }
   
   PlayerPhasedOut(who=$)
   {
      return;
   }
   
   PlayerPhasedIn(who=$)
   {
      return;
   }

   HasMasteredThisSkill()
   {
      return FALSE;
   }

   HasMasteredThisSpell()
   {
      return FALSE;
   }

   GetCanSpawnAsChampion()
   {
      return viCanSpawnAsChampion;
   }

   AddLevel(value=10)
   {
      piLevel = Bound(piLevel + value,20,$);
      return piLevel;
   }

   ResetLevel()
   {
      piLevel = viLevel;
      return;
   }

   TaughtPlayerSpell(who=$,num=0)
   {
      return;
   }

   GetBonusBaseTP()
   {
      return viBonusBaseTP;
   }

   ApplyKnockback(what=$, iRow=0, iCol=0, iFineRow=0, iFineCol=0, knockback_power=0, knockback_angle=0)
   {
      if (piBehavior & AI_NPC)
      {
         return FALSE;
      }
      propagate;
   }

   ApplyStun(what=$, stun_power=0)
   {
      if (piBehavior & AI_NPC)
      {
         return FALSE;
      }
      propagate;
   }

   ApplyBleed(what=$, bleed_power = 0)
   {
      if (piBehavior & AI_NPC)
      {
         return FALSE;
      }
      propagate;
   }

   RecalcLight()
   {
      return;
   }

   PlayerHealedSomeone(caster=$, oTarget=$, iHealAmount=0)
   {
      if caster = $
         OR oTarget = $
         OR poMaster <> $
      {
         return;
      }

      if NOT (piBehavior & AI_FIGHT_SINGLEMINDED)
         AND NOT (piBehavior & AI_NOFIGHT)
         AND NOT (piBehavior & AI_NPC)
      {
         % Caster healed our target!
         if oTarget = poTarget
         {
            Send(self,@PlayerHealedOurTarget,#caster=caster,#oTarget=oTarget,#iHealAmount=iHealAmount);
         }
         else
         {
            Send(self,@PlayerHealedNotOurTarget,#caster=caster,#oTarget=oTarget,#iHealAmount=iHealAmount);
         }
      }
      return;
   }

   PlayerHealedOurTarget(caster=$, oTarget=$, iHealAmount=0)
   {
      if caster <> oTarget
      {
         % Someone's healing our target!
         if Random(1,100) < iHealAmount
         {
            Send(self,@TargetSwitch,#what=caster,#iHatred=iHealAmount*10);
            Send(self,@EnterStateChase,#target=caster,#actnow=TRUE);
         }
      }
      return;
   }

   PlayerHealedNotOurTarget(caster=$, oTarget=$, iHealAmount=0)
   {
      if caster <> oTarget
         AND poTarget = $
      {
         if piHatred < iHealAmount
            AND Random(1,100) < iHealAmount
            AND Send(self,@SquaredFineDistanceTo3D,#what=caster) <= viReactToHealFineDist * viReactToHealFineDist
         {
            Send(self,@TargetSwitch,#what=caster,#iHatred=iHealAmount*10);
            Send(self,@EnterStateChase,#target=caster,#actnow=TRUE);
         }
      }
      return;
   }

   IsShadow()
   {
      % This is a type like Undead, except representing shadows and darkness.
      return vbIsShadow;
   }

   GetElementalImbalancePower()
   {
      return piApplyElementalImbalancePower;
   }

   GetBonusXPGain()
   {
      return vbBonusXPGain;
   }

   GetPlayerUsing()
   {
      % Human monsters can equip items.
      return $;
   }

   WasHeld()
   {
      return;
   }

   WasBlinded()
   {
      return;
   }

   GetLoyalty()
   {
      return piLoyalty;
   }

   AddLoyalty(amount=0, cap_at=MAX_LOYALTY)
   {
      piLoyalty = Bound(piLoyalty + amount, 0, cap_at);
      
      if piLoyalty > 0
         AND ptLoyaltyTimer = $
      {
         ptLoyaltyTimer = CreateTimer(self,@LoyaltyTimer,3000);
      }
      
      return piLoyalty;
   }

   LoyaltyTimer(timer=$)
   {
      local iPreviousLoyalty;

      ptLoyaltyTimer = $;
      
      if poMaster = $
      {
         Send(self,@BreakAllegiance);
         return;
      }
      
      if piLoyalty >= 10 * LOYALTY_PER_BINDING_LEVEL
      {
         % We're a permanent minion.
         ptLoyaltyTimer = CreateTimer(self,@LoyaltyTimer,60000);
         return;
      }
      
      if poOwner <> $
         AND Send(poOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
      {
         % No loyalty loss in safe areas.
         ptLoyaltyTimer = CreateTimer(self,@LoyaltyTimer,60000);
         return;
      }
      
      if IsClass(poMaster,&Player)
         AND Send(poMaster,@IsInCannotInteractMode)
      {
         ptLoyaltyTimer = CreateTimer(self,@LoyaltyTimer,60000);
         return;
      }
      
      iPreviousLoyalty = piLoyalty;
      
      if Send(self,@HasCreatureType,#type=CREATURE_TYPE_INTELLIGENT)
      {
         % Intelligent mobs shrug off charms faster
         piLoyalty--;
      }

      if Send(poMaster,@GetKarma) > 0
         AND Send(self,@HasCreatureType,#type=CREATURE_TYPE_UNDEAD)
      {
         % Undead don't like positive karma masters
         piLoyalty--;
      }

      if Send(poMaster,@GetKarma) < 0
         AND Send(self,@HasCreatureType,#type=CREATURE_TYPE_HUMANOID)
      {
         % Humanoids don't generally trust negative karma masters
         piLoyalty--;
      }

      % Generic drop
      piLoyalty--;
      
      if piLoyalty <= 0
      {
         piLoyalty = 0;
         Send(self,@BreakAllegiance);
      }
      else
      {
         if poMaster <> $
            AND IsClass(poMaster,&Player)
            AND iPreviousLoyalty/LOYALTY_PER_BINDING_LEVEL <> piLoyalty/LOYALTY_PER_BINDING_LEVEL
         {
            if piLoyalty/LOYALTY_PER_BINDING_LEVEL > 2
            {
               Send(poMaster,@MsgSendUser,#message_rsc=minion_breaks_bind_level_high,#parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
            }
            else
            {
               Send(poMaster,@MsgSendUser,#message_rsc=minion_breaks_bind_level_low,#parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
            }
         }
         ptLoyaltyTimer = CreateTimer(self,@LoyaltyTimer,3000);
      }
      
      return;
   }

   BreakAllegiance()
   {
      local oPreviousMaster;
      
      if ptLoyaltyTimer <> $
      {
         DeleteTimer(ptLoyaltyTimer);
         ptLoyaltyTimer = $;
      }
      
      piLoyalty = 0;

      if poMaster <> $
      {
         Send(poMaster,@MsgSendUser,#message_rsc=minion_breaks_free,#parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
         oPreviousMaster = poMaster;
      }
      Send(self,@SetMaster,#oMaster=$);
      Send(self,@ResetBehaviorFlags);
      if poOwner <> $
      {
         if IsClass(poOwner,&AdventurersGuild)
            AND Send(Send(SYS,@GetLeagueMaintenance),@GetFundingLevel) >= 1
         {
            Send(poOwner,@MonsterBrokeAllegiance,#what=self,#oPreviousMaster=oPreviousMaster);
            return;
         }
         Send(poOwner,@SomethingChanged,#what=self);
      }
      
      if vbSummoned
      {
         Post(self,@Delete);
      }
      return;
   }
   
   GetCharmResistance()
   {
      % This is a percentage value
      return piLevel/4;
   }

   StartSwimming()
   {
      piDrawEffectFlag = piDrawEffectFlag | OF_BOUNCING;
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }
      return;
   }
   
   StopSwimming()
   {
      piDrawEffectFlag = (piDrawEffectFlag & (~OF_BOUNCING));
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }
      return;
   }

   GetLanguage()
   {
      return viLanguage;
   }

   AttemptConversation(who=$)
   {
      local oLanguageMaintenance;
      
      oLanguageMaintenance = Send(SYS,@GetLanguageMaintenance);
      
      Send(oLanguageMaintenance,@AttemptConversation,#who=who,#oMonster=self);
      return;
   }
   
   GetMeleeSpellBook()
   {
      return plMeleeSpellBook;
   }
   
   GetRangedSpellBook()
   {
      return plRangedSpellBook;
   }
   
   GetSelfSpellBook()
   {
      return plSelfSpellBook;
   }
   
   GetAllySpellBook()
   {
      return plAllySpellBook;
   }
   
   GetOtherSpellBook()
   {
      return plOtherSpellBook;
   }

   GainHealth(amount = $, precision = FALSE)
   "Vamp drain & heal"
   {
      if NOT precision
      {
         amount = amount*100;
      }

      piHit_points = piHit_points + amount;

      return;
   }

   ReportHealthToAllies(what=$,damage=0,atype=0,aspell=0,bonus=0,scalefactor=1000,
      absolute=FALSE,precision=FALSE,bDoingBackstab=FALSE,bSecondary=FALSE)
   {
      local i, oRoom;
      
      oRoom = Send(self,@GetOwner);
      if oRoom <> $
      {
         foreach i in Send(oRoom,@GetHolderActive)
         {
            if First(i) <> self
               AND IsClass(First(i),&Monster)
               AND Send(self,@IsAlly,#target=First(i))
            {
               Send(First(i),@AllyReportsHealth,#who=self,#health_ratio=(Send(self,@GetHealth)*100)/Send(self,@GetMaxHealth),
                                                #what=what,#damage=damage,#atype=atype,#aspell=aspell,#bonus=bonus,#scalefactor=scalefactor,
                                                #absolute=absolute,#precision=precision,#bDoingBackstab=bDoingBackstab,#bSecondary=bSecondary);
            }
         }
      }
      return;
   }
   
   AllyReportsHealth(who=$, health_ratio=100,what=$,damage=0,atype=0,aspell=0,bonus=0,scalefactor=1000,
      absolute=FALSE,precision=FALSE,bDoingBackstab=FALSE,bSecondary=FALSE)
   {
      return;
   }

   CancelCastingAnimation()
   {
      if ptCastingAnimationTimer <> $
      {
         DeleteTimer(ptCastingAnimationTimer);
         ptCastingAnimationTimer = $;
         piCastPower = 0;
         Send(self,@UpdateCastingLightLevel);
      }
      return;
   }

   CastingAnimationStep(timer=$)
   {
      ptCastingAnimationTimer = $;
      
      piCastPower = piCastPower + piCastSpeed;
      
      if piCastPower >= piCastingRequiredPower
      {
         Send(self,@CastingComplete);
         return;
      }
      else
      {
         Send(self,@UpdateCastingLightLevel);
      }

      ptCastingAnimationTimer = CreateTimer(self,@CastingAnimationStep,100);
      return;
   }

   CastingComplete()
   {
      local oSpell;
      if poTarget <> $
         AND Send(poTarget,@GetOwner) = poOwner
         AND isClass(poTarget,&User)
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_BLAST_OF_FIRE);
                  Send(oSpell,@CastSpell,#who=self,#lTargets=[poTarget],
                        #iSpellPower=90);
      }
      piCastPower = 0;
      Send(self,@UpdateCastingLightLevel);
      return;
   }

   CastingTest()
   {
      % How long is our casting step?
      % We go from 0 to 240 light level at 100 ms per step
      % 1000 ms casting time = 10 steps of 24
      % 2000 ms casting time = 20 steps of 12
      % 3000 ms casting time = 30 steps of 8
      % 4000 ms casting time = 40 steps of 6
      
      piCastPower = 0;
      piCastingSID = SID_BLAST_OF_FIRE;
      piCastingColor = LIGHT_RED;
      piCastingRequiredPower = 240;
      
      if ptCastingAnimationTimer <> $
      {
         DeleteTimer(ptCastingAnimationTimer);
         ptCastingAnimationTimer = $;
      }

      Send(self,@PlayCastingSound,#sound_num=4);
      ptCastingAnimationTimer = CreateTimer(self,@CastingAnimationStep,100);
      
      return;
   }

   UpdateCastingLightLevel()
   {
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }
      return;
   }

   PlayCastingSound(sound_num=1)
   {
      local i;

      switch(sound_num)
      {
         case 1:
            i = monster_spell_build_1_sound;
            break;
         case 2:
            i = monster_spell_build_2_sound;
            break;
         case 3:
            i = monster_spell_build_3_sound;
            break;
         case 4:
            i = monster_spell_build_4_sound;
            break;
      }
      if poOwner <> $
         AND IsClass(poOwner,&Room)
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=i);
      }
      if poTarget <> $
         AND IsClass(poTarget,&User)
      {
         Send(poTarget,@WaveSendUser,#what=self,#wave_rsc=i);
      }
      return;
   }

   GetMoveOnType(who=$)
   {
      local iFlags;

      iFlags = viMoveOn_type;

      % Minions cannot block other players.
      if poMaster <> $
         AND who <> $
         AND IsClass(who,&Player)
      {
         iFlags = (iFlags & ~MOVEON_NO);
      }

      return iFlags;
   }
   
   CreateMeleeSpellBookIfNew(iSID = 0, iManaCost = 0, iChance = 100, iSpellpower = 0)
   {
      if plMeleeSpellBook = $
      {
         plMeleeSpellBook = [[iSID, iManaCost,iChance,iSpellpower]];
      }
      return;
   }
   
   ClearAttackTimer()
   {
      return;
   }

   WeightPrefixes()
   {
      % Some monsters weight mod chances.
      % For example, an avar warrior puts an emphasis on vigor mods.
      return $;
   }
   
   WeightSuffixes()
   {
      return $;
   }

   EmpowerAffixes()
   {
      % Some monsters improve the range of power of a mod.
      % If the value is 3, for example, the rolled result of a mod is given +3.
      return $;
   }
   
   AllowPlayerAttack()
   {
      return TRUE;
   }
   
   GetEpicRarityBoost()
   {
      return 0;
   }
   
   GetRareRarityBoost()
   {
      return 0;
   }
   
   GetMagicRarityBoost()
   {
      return 0;
   }
   
   CanBeCharmed()
   {
      return TRUE;
   }
   
   GetLadderID()
   {
      if poMaster <> $
      {
         return Send(poMaster,@GetLadderID);
      }
      propagate;
   }
   
   GetLeadershipCost()
   {
      if viLeadershipCost <> 0
      {
         return viLeadershipCost * Send(self,@GetChampionRewardMultiplier);
      }
      return piLevel * Send(self,@GetChampionRewardMultiplier);
   }
   
   GetFreeLeadership()
   {
      return Bound(Send(self,@CalculateLeadershipMax,#bCharming=FALSE) - Send(self,@CalculateLeadershipUsed),0,$);
   }

   CalculateLeadershipMax(oMonster=$, bCharming=TRUE)
   {
      return viLeadershipMax;
   }

   CalculateLeadershipUsed()
   {
      local iControlledLeadershipCosts, oActive;

      iControlledLeadershipCosts = 0;
      foreach oActive in plControlledMinions
      {
         if IsClass(oActive,&Monster)
         {
            iControlledLeadershipCosts = iControlledLeadershipCosts + Send(oActive,@GetLeadershipCost);
         }
      }
      
      return iControlledLeadershipCosts;
   }

   CanControlNewMinion(oMonster=$, bCharming=TRUE)
   {
      local iControlledLeadershipCosts, oActive, iLeadershipMax, iMonsterLeadershipCost;
      
      if oMonster = $
         OR NOT Send(oMonster,@CanBeCharmed)
      {
         return FALSE;
      }

      iLeadershipMax = Send(self,@CalculateLeadershipMax,#oMonster=oMonster,#bCharming=bCharming);
      iControlledLeadershipCosts = Send(self,@CalculateLeadershipUsed);
      iMonsterLeadershipCost = Send(oMonster,@GetLeadershipCost);

      if iControlledLeadershipCosts + iMonsterLeadershipCost <= iLeadershipMax
      {
         return TRUE;
      }
      
      % We're over our limit.
      return FALSE;
   }

   GetEventSpawner()
   {
      return poEventSpawner;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
